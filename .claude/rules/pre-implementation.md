# 実装前の必須確認（Pre-Implementation Checklist）

コードを書く前に、以下を確認する。**推測で書かない。**

## 原則

- 「書いて試す」ではなく「読んで理解してから書く」
- 型システムは「エラー検出」ではなく「設計を導くもの」
- コンパイラに頼る前に、自分で型の整合性を確認する

## Rust

### 1. 型定義の確認

使用する型の定義を読む：

- 構造体のフィールド名と型
- enum のバリアント
- `impl` ブロックで提供されているメソッド
- `derive` されているトレイト

```rust
// ❌ 推測で書く
let user = User { name: name.into(), ... };

// ✅ 型定義を確認してから書く
// User の定義を読み、フィールドが name: UserName であることを確認
let user = User { name: UserName::new(name), ... };
```

### 2. インポートパスの確認

`use` 文を先に確定させる：

- 既存コードで同じ型をどうインポートしているか確認
- re-export の構造を理解する（`crate::prelude` など）

```rust
// ❌ 推測でパスを書く
use crate::domain::user::User;

// ✅ 既存コードのインポートパターンを確認
use crate::domain::user::{User, UserId, UserName};
```

### 3. 既存パターンの確認

類似の実装を読む：

- 同じレイヤーの他のモジュール
- 同じ種類の処理（ハンドラなら他のハンドラ、リポジトリなら他のリポジトリ）
- エラーハンドリングのパターン

### 4. トレイト境界の確認

ジェネリクスを使う場合：

- 必要なトレイト実装が存在するか
- `where` 句の制約を確認

### 5. エラー型の確認

Result を返す場合：

- エラー型の定義とバリアントを確認
- `?` 演算子で変換が必要か（`From` トレイトの実装有無）

## Elm

### 1. 型エイリアスとカスタム型の確認

使用する型の定義を読む：

- レコードのフィールド名と型
- カスタム型のバリアント（コンストラクタの引数）

```elm
-- ❌ 推測で書く
User name email

-- ✅ 型定義を確認してから書く
-- type alias User = { name : String, email : Email } を確認
{ name = name, email = email }
```

### 2. モジュールの公開関数の確認

`exposing` を確認：

- どの関数・型が公開されているか
- 不透明型（Opaque Type）の場合、コンストラクタは非公開

```elm
-- ❌ 直接コンストラクタを使おうとする
Email emailString

-- ✅ スマートコンストラクタを使う（公開されている関数を確認）
Email.fromString emailString
```

### 3. 既存パターンの確認

類似の実装を読む：

- 同種のモジュール（Page なら他の Page）
- Msg と update の構造
- Cmd の扱い方

### 4. デコーダの確認

JSON を扱う場合：

- 既存のデコーダのパターンを確認
- フィールド名の命名規則（camelCase vs snake_case）

## 確認のタイミング

| タイミング | 確認すること |
|-----------|-------------|
| 新しい型を使う前 | 型定義、インポートパス |
| 新しいモジュールを作る前 | 同種の既存モジュール |
| 関数を実装する前 | 引数と戻り値の型、エラー型 |
| テストを書く前 | テストユーティリティ、既存テストのパターン |

## 禁止事項

- 型定義を確認せずにフィールドアクセスを書くこと
- インポートパスを推測で書くこと
- 「コンパイルして確認すればいい」と考えること
- 既存パターンを確認せずに独自の書き方をすること

## AI エージェントへの指示

- コードを書く前に、関連する型定義を必ず Read ツールで読む
- 類似の実装がある場合は、先にそれを読んでパターンを把握する
- 不確かな場合は書く前に確認する。「書いて試す」に頼らない
