# TDD 開発フロー

TDD 開発フローの AI ディレクティブ版。教育的解説・参考資料は [手順書](../../docs/04_手順書/04_開発フロー/02_TDD開発フロー.md) を参照。

## 確認事項の実施

各 Phase のテストを書き始める前に、計画ファイルの確認事項を Read/Grep で実施する。

→ 原則: [実装前の確認](pre-implementation.md)

1. 型: Read ツールで型定義を確認
2. パターン: Read ツールで参照ファイルを確認
3. ライブラリ: Grep で既存使用を確認。初めて使う API は docs.rs / package.elm-lang.org で確認

確認事項はゲート条件。確認を実施してから実装に入る。計画ファイルへの状態更新は不要（証跡は Read/Grep の実行そのもの）。確認の結果、設計判断の変更が生じた場合はセッションログの判断ログにも記録する。

実装中に計画外の API が必要になった場合は、その場で同じ手順を実施する。Phase 開始時に 1 回実施。TDD サイクルの各イテレーションでは不要。

## TDD サイクル

Red → Green → Refactor を繰り返す。

### Red: 失敗するテストを書く

#### 二層の Red モデル

| レベル | フィードバック源 | 教えてくれること | 書くもの |
|--------|----------------|----------------|---------|
| Red (compile) | コンパイラ | 何を定義すべきか | 型定義、関数シグネチャ、`todo!()` / `Debug.todo` |
| Red (test failure) | テストランナー | 何を実装すべきか | — （失敗を確認するだけ） |

手順:
1. テストを 1 つ書く → Red: compile
2. コンパイルエラーを解消する → Green: compile / Red: test failure
3. テストを実行して失敗を確認する

ゲート: テストが失敗（Red）であること → Green フェーズへ

**禁止:** テスト失敗を確認せずに実装コードを書くこと

#### コンパイルエラー解消の原則

| 書くもの | 書かないもの |
|---------|------------|
| 構造体、enum の型定義 | フィールドの値を計算するロジック |
| 関数シグネチャ（引数と戻り値の型） | 関数の本体ロジック |
| `todo!()`（Rust）/ `Debug.todo`（Elm） | 条件分岐、ループ、ビジネスルール |
| トレイト実装の骨格 | トレイトメソッドの具体的な処理 |

### Green: 最短で通す

テストを通す最小限のコードを書く。

1. 仮実装（Fake It）: 定数を返すなど最も単純な実装
2. 明白な実装（Obvious Implementation）: 答えが明らかなら直接実装

コードの美しさは後回し。重複や汚いコードは許容する。

### Refactor: 設計を改善する

動作を変えずに設計品質を高める。**テストが通り続けることを確認しながら**進める。

プロダクションコード: 重複除去、命名改善、構造整理。
テストコード: テスト名の意図確認、冗長テストの削除、AAA 構造の確認。

#### 設計原則レンズ

→ 位置づけ: [zoom-rhythm.md > 実装中の俯瞰](zoom-rhythm.md#実装中の俯瞰-設計原則レンズ)

毎 Refactor:

| レンズ | 問い |
|--------|------|
| 意図の明確さ | このコードの意図は読み手に伝わるか？ 手がかり: 関数名が「何をするか」を伝えているか / 変数名が計算の意味を表しているか / コメントが必要なら命名やヘルパー関数で解決できないか |
| 重複の排除 | 同じ知識が複数箇所に存在していないか？新しく書いたコードの主要パターンを Grep で既存コードと照合する |
| 要素の最小性 | 不要な中間変数、引数、構造体フィールドはないか？ |

モジュール/関数の完成時:

| レンズ | 問い |
|--------|------|
| 単一責務（SRP） | この関数/モジュールに変更理由は 1 つだけか？ 手がかり: Handler は API 契約変更、UseCase はビジネスルール変更、Repository は DB スキーマ変更、Domain Entity はドメインモデル変更。複数混在していたら分離の兆候 |
| 依存方向（DIP） | 依存の方向は正しいか？ 手がかり: `apps → domain → shared`, `apps → infra → shared` に違反する import がないか / domain が infra の具体型に依存していないか / 新しい外部依存は trait で抽象化し `Arc<dyn Trait>` で注入しているか |
| 型の活用 | 不正な状態や操作を型で防げていないか？ Newtype（[ADR-016](../../docs/05_ADR/016_プリミティブ型のNewtype化方針.md)）/ 型安全ステートマシン（[ADR-054](../../docs/05_ADR/054_型安全ステートマシンパターンの標準化.md)）/ 構造的強制（[ADR-051](../../docs/05_ADR/051_トランザクションコンテキストによる構造的強制.md)）/ 境界での型変換 / 不変条件の保護 |

発見があった場合のみ、セッションログの判断ログに記録する。

#### UI/UX レンズ（フロントエンド変更時）

→ デザインガイドライン: [`docs/03_詳細設計書/13_デザインガイドライン.md`](../../docs/03_詳細設計書/13_デザインガイドライン.md)
→ デザイントークン: [`frontend/src/styles.css`](../../frontend/src/styles.css)

毎 Refactor:

| レンズ | 問い |
|--------|------|
| デザイントークン準拠 | デザインガイドラインに準拠しているか？生の色値・未定義シェードはないか？ |
| 共有コンポーネント活用 | 既存の共有コンポーネント（Button, Badge, FormField, ErrorState, EmptyState 等）で実現できないか？ |
| 状態の網羅性 | RemoteData の全状態（NotAsked/Loading/Failure/Success）と空データにフィードバックがあるか？ |

ページ/コンポーネントの完成時:

| レンズ | 問い |
|--------|------|
| アクセシビリティ | セマンティック HTML、ARIA 属性、キーボード操作（focus-visible）、フォームの label 関連付けが適切か？ |
| エラーのユーザビリティ | エラー表示がユーザーの言語で表現され、回復手段を提供しているか？ |
| 視覚的階層 | タイポグラフィ階層に沿い、関連要素が近接でグルーピングされているか？ |
| 破壊的操作の防御 | 削除・却下等に ConfirmDialog があり、ボタン色が操作の意味と一致しているか？ |

デザイン品質向上（ページ/コンポーネントの完成時）:

| レンズ | 問い |
|--------|------|
| コントラストの効果 | 重要な要素（CTA、見出し、状態バッジ）が周囲と明確に差別化されているか？ |
| 整列の一貫性 | スペーシンググリッド（4px 基準）に沿って整列しているか？ |
| 余白の活用 | 余白がグルーピングと呼吸感を適切に生み出しているか？ |

## 操作パスの列挙

テストリスト作成前に、ユーザーの操作パスを列挙する。テスト設計は「ユーザーの操作パス」から出発する。

### 適用条件

| Issue の種類 | 適用 |
|-------------|------|
| フルスタック機能（UI + API + DB） | 必須 |
| API のみ（UI なし） | 必須 |
| ドメインロジックのみ | 推奨 |
| ドキュメント・インフラ | 不要 |

### 手順

1. Issue の完了基準を確認
2. 完了基準からユーザー操作の正常系パスを列挙
3. 各正常系パスの分岐点で準正常系・異常系パスを導出
4. 各操作パスをテスト層に対応づける

### 操作パスの分類

| 分類 | 内容 |
|------|------|
| 正常系 | 期待通りの成功パス |
| 準正常系 | 設計されたエラー処理（ユーザー起因） |
| 異常系 | 想定外の障害（システム起因） |

### テスト層への変換

| 操作パスの性質 | 主なテスト層 |
|--------------|------------|
| UI からの操作完結性 | E2E |
| API エンドポイントの入出力 | API テスト / ハンドラテスト |
| ドメインルールの検証 | ユニットテスト |
| エラーハンドリング（UI 表示） | E2E |
| エラーハンドリング（API レスポンス） | API テスト / ハンドラテスト |
| エラーハンドリング（ロジック） | ユニットテスト |

1 つの操作パスが複数のテスト層にまたがることがある。

### テスト設計の方向性

設計（トップダウン）: 操作パス → テスト層の配置 → テストリスト
実装（ボトムアップ）: ユニットテスト → ハンドラテスト → API テスト → E2E テスト

## テストリスト

テストピラミッドの各層を明記する。該当しない層は「該当なし」と記載し、省略しない。

→ テストピラミッドの概念整理: [ナレッジベース: テストピラミッド](../../docs/06_ナレッジベース/methodology/テストピラミッド.md)

| テスト層 | 検証対象 | 該当条件 |
|---------|---------|---------|
| ユニットテスト | ドメインロジック、ユースケース | 常に |
| ハンドラテスト | HTTP ハンドラの入出力、認可 | HTTP ハンドラがある場合 |
| API テスト（Hurl） | 実 DB を含むエンドポイント結合 | 公開 API エンドポイントがある場合 |
| E2E テスト（Playwright） | ユーザー操作の完結性 | UI 操作を伴う場合 |

作成のコツ: 操作パスから逆算 → 正常系 → 準正常系 → 異常系 → 境界値の順。

## MVP 積み上げ方式

| 原則 | 説明 |
|------|------|
| 垂直スライス | 1つの機能を端から端まで動かす |
| 常に動く状態 | 各ステップ完了時点で動作確認できる |
| 依存順に積む | 下位レイヤーから順に実装 |

## テストレビュー（Phase 完了時）

各 Phase の TDD サイクル完了後、テストを品質保証の観点でレビューする。

| 観点 | 確認内容 |
|------|---------|
| 冗長性 | 本実装後に同じことを検証しているテストがないか |
| 網羅性 | 正常系・異常系・境界値が体系的に網羅されているか |
| 明確さ | テスト名から仕様が読み取れるか |
| 構造 | 正常系 → 異常系 → 境界値の並び順か |

## E2E テスト実行タイミング

E2E テストは TDD の Red-Green-Refactor サイクルには組み込まない。

| タイミング | 実行するテスト |
|-----------|--------------|
| TDD サイクル中 | `cargo test` / `elm-test`（ユニットテスト） |
| Phase 完了時 | `just check`（lint + ユニット + 統合テスト） |
| UI に影響する変更時 | `just test-e2e` で明示的に確認 |

→ E2E テストの詳細: [Playwright ナレッジベース](../../docs/06_ナレッジベース/devtools/Playwright.md)
→ E2E テストのルール: [e2e-test.md](e2e-test.md)

## テスト規約

### sut 命名

テスト対象オブジェクトの変数名には `sut`（System Under Test）を使用する。

| テスト対象 | `sut` の変数 | 依存関係（`sut` にしない） |
|-----------|-------------|--------------------------|
| Usecase | `let sut = XxxUseCaseImpl::new(...)` | Mock リポジトリ |
| Repository | `let sut = PostgresXxxRepository::new(pool)` | 前提データ用の別リポジトリ |
| Handler | `let sut = create_test_app(...)` | スタブクライアント |
| Session | `let sut = RedisSessionManager::new(...)` | テストデータ |

テスト対象のみ `sut` にする。依存関係は意味のある名前を維持する。
