# 2026-01-16 テスト最適化と Clippy 修正

## セッション概要

Phase 1 のドメインモデル実装後、テスト品質とコード品質を向上させるためのリファクタリングを実施。

## 実施内容

### 1. テスト粒度の見直し

**問題提起:**
ユーザーから「シナリオテストでもないのに1テストにassertありすぎじゃないか」という指摘。

**現状分析:**
- `test_email_validation`: 4つのassert（正常系、空、@なし、長すぎる）
- `test_user_creation`: 4つのassert（is_active, can_login, name, last_login_at）
- `test_permission_includes`: 7つのassert

**ルールの曖昧さ:**
既存の `.claude/rules/rust.md` には「1テスト1アサーション（または関連するアサーションのみ）」と記載されていたが、「関連するアサーションのみ」の判断基準が不明確。

**議論:**
- 「関連するアサーション」の解釈が曖昧
- User::new()の不変条件を確認する4つのassert → 関連していると言えるが、失敗時の原因特定は？
- ルールを明確化する必要がある

### 2. 最適なテストアプローチの検討

**要件:**
- テスト名を日本語にする
- `test_` プレフィクスは必要（数字始まりの名前に対応）
- AAA パターンの簡潔な記述方法
- バリデーションのパラメータ化

**検討した手法:**

#### AAA パターンの代替案
1. **空行で3セクション分離** ← 採用
   - コメント不要、視覚的に明確
   - Rust 標準ライブラリや tokio で採用

2. Given-When-Then（BDD）
   - 意図が明確だが冗長

3. セットアップヘルパー
   - 再利用可能だが、テスト本体外の定義が必要

4. 自然に（短いテストのみ）
   - 1行で済むテストに適用

#### Given/Then の肥大化対策
1. **rstest フィクスチャ** ← 採用
   - セットアップを共通化

2. カスタム assertion
   - 複雑な検証を簡潔化

3. Builder パターン
   - 複雑なセットアップに有効

### 3. rstest 導入とリファクタリング

**rstest の機能:**
- `#[fixture]`: テストの共通セットアップ
- `#[rstest]` + `#[case(...)]`: パラメータ化テスト

**実装:**

#### フィクスチャの定義
```rust
#[fixture]
fn アクティブなユーザー() -> User {
    let tenant_id = TenantId::new();
    let email = Email::new("user@example.com").unwrap();
    User::new(tenant_id, email, "Test User".to_string(), None)
}
```

#### パラメータ化テスト
```rust
#[rstest]
#[case("", "空文字列")]
#[case("no-at-sign", "@記号なし")]
#[case(&format!("{}@example.com", "a".repeat(256)), "255文字超過")]
fn test_メールアドレスは不正な形式を拒否する(#[case] input: &str, #[case] _reason: &str) {
    assert!(Email::new(input).is_err());
}
```

#### フィクスチャを使用したテスト
```rust
#[rstest]
fn test_削除されたユーザーはログインできない(アクティブなユーザー: User) {
    let deleted = アクティブなユーザー.deleted();

    assert!(!deleted.can_login());
}
```

**効果:**
- Email バリデーション: 4テスト → 2テスト（1正常系 + 1パラメータ化）
- Permission 包含判定: 8テスト → 3テスト（2基本 + 1パラメータ化）
- Role 権限チェック: 4テスト → 1パラメータ化テスト
- コード重複削減、テストケース追加が容易に

### 4. ルールの明確化

`.claude/rules/rust.md` に追加:

```markdown
### テストの粒度

原則: 1テスト1検証観点

各テストは単一の振る舞いまたは条件を検証する。

判断基準:
- テスト名で検証内容が明確に表現できるか
- テストが失敗したとき、何が壊れたか即座に分かるか
- セットアップコードの重複よりも、テストの明確さを優先
```

### 5. Clippy による品質改善

**実行:**
```bash
cargo clippy --all-targets -- -D warnings
```

**検出された問題（7件）:**

#### 1. collapsible_if（2箇所）
**role.rs:114, workflow.rs:839**

```rust
// Before
if let Some(resource) = self.0.strip_suffix(":*") {
    if let Some(other_resource) = other.0.split(':').next() {
        return resource == other_resource;
    }
}

// After (let chain)
if let Some(resource) = self.0.strip_suffix(":*")
    && let Some(other_resource) = other.0.split(':').next()
{
    return resource == other_resource;
}
```

**解説:**
Rust 1.65+ の let chain 構文を使用して、ネストした if let を簡潔に記述。

#### 2. should_implement_trait（5箇所）
**user.rs, workflow.rs の各 Status enum**

```rust
// Before
impl UserStatus {
    pub fn from_str(s: &str) -> Result<Self, DomainError> { ... }
}

// After
impl std::str::FromStr for UserStatus {
    type Err = DomainError;
    fn from_str(s: &str) -> Result<Self, Self::Err> { ... }
}
```

**対象:**
- `UserStatus`
- `WorkflowDefinitionStatus`
- `WorkflowInstanceStatus`
- `WorkflowStepStatus`
- `StepDecision`

**メリット:**
- 標準ライブラリのトレイトに準拠
- `.parse::<UserStatus>()` などの標準的な変換が可能
- エコシステムとの統合が容易

#### 3. non_snake_case（3箇所）
**テスト名の警告**

```rust
// Before
fn test_システムロールはテナントIDを持たない()
fn test_テナントロールはテナントIDを持つ()
fn test_削除されたユーザーのステータスはDeleted()

// After
fn test_システムロールはテナントidを持たない()
fn test_テナントロールはテナントidを持つ()
fn test_削除されたユーザーのステータスは削除済み()
```

**対応:**
- 英字の略語（ID）を小文字化
- 英単語（Deleted）を日本語化

### 6. アーキテクチャの議論

#### packages/ の意義

**現状:**
```
packages/
├── domain/      # Core API でのみ使用
├── infra/       # Core API でのみ使用
└── shared/      # BFF, Core API 両方で使用
```

**議論:**
- Phase 1 (MVP) では domain, infra は Core API でしか使わない
- apps/core-api/src/domain/ でも十分では？
- Phase 4（イベント駆動）で複数サービスがドメインを共有する場合は意義がある

**結論:**
- 「packages での分離」自体が学習目標
- 将来の拡張を見据えた構成として現状維持

#### packages という名前の適切性

**問題:**
`packages/` は JavaScript/TypeScript の monorepo 用語で、Rust では一般的ではない。

**Rust エコシステムの慣習:**
1. `crates/` - 最も一般的（Rust Analyzer, ripgrep など）
2. `libs/` - ライブラリの意味が明確
3. フラット or 目的別

**推奨: `crates/`**
- Cargo workspace のメンバーは「クレート」という正式名称
- Rust コミュニティで最も一般的

**対応:**
別 PR で対応することに決定。

## 成果物

### コード変更
- `Cargo.toml`: rstest 追加
- `packages/domain/Cargo.toml`: rstest 追加
- `packages/domain/src/user.rs`: テストリファクタリング、FromStr 実装
- `packages/domain/src/role.rs`: テストリファクタリング、collapsible_if 修正
- `packages/domain/src/workflow.rs`: FromStr 実装、collapsible_if 修正

### ドキュメント更新
- `.claude/rules/rust.md`: テスト粒度の原則を明確化、rstest の使用例追加

### テスト結果
- テスト数: 30件（変わらず）
- 全テスト成功
- Clippy 警告: 0件

## 学んだこと

### 1. テストの粒度は「検証観点」で判断
「1テスト1アサーション」は機械的なルールではなく、「1つの検証観点」を意味する。
- 失敗時に何が壊れたか即座に分かるか
- テスト名で検証内容が明確に表現できるか

### 2. rstest の威力
- フィクスチャでセットアップの重複を削減
- パラメータ化でバリデーションテストを簡潔化
- テストケースの追加が容易

### 3. Clippy の有用性
- let chain で可読性向上
- FromStr トレイトで標準ライブラリとの統合
- 一貫性のあるコードベースの維持

### 4. 命名の重要性（packages vs crates）
エコシステムの慣習に従うことで、他の開発者にとって理解しやすいコードベースになる。

## 次のステップ

1. 現在の変更をコミット
2. packages/ → crates/ のリネーム（別 PR）
3. Core API リポジトリ実装（データアクセス層）

## 技術メモ

### rstest の基本

```rust
// フィクスチャ
#[fixture]
fn setup() -> Data {
    Data::new()
}

// パラメータ化
#[rstest]
#[case(input1, expected1)]
#[case(input2, expected2)]
fn test_name(#[case] input: T, #[case] expected: U) {
    assert_eq!(func(input), expected);
}

// フィクスチャ + パラメータ化
#[rstest]
#[case("test1")]
#[case("test2")]
fn test_with_fixture(setup: Data, #[case] input: &str) {
    assert!(setup.process(input).is_ok());
}
```

### let chain 構文

Rust 1.65+ で安定化。複数の let パターンを `&&` で連結可能。

```rust
if let Some(x) = opt1
    && let Some(y) = opt2
    && x > 0
{
    // both are Some and x > 0
}
```

### FromStr トレイト

標準ライブラリのトレイト。文字列からの変換を標準化。

```rust
impl std::str::FromStr for MyType {
    type Err = MyError;
    fn from_str(s: &str) -> Result<Self, Self::Err> { ... }
}

// 使用例
let value: MyType = "input".parse()?;
```

---

## 変更履歴

| 日付 | 変更内容 |
|------|----------|
| 2026-01-16 | 初版作成 |
