# 2026-02-01 ユーザー名解決の実装

## 概要

Issue #196: 申請詳細画面・タスク詳細画面でユーザー ID が UUID 表示されていた問題を修正した。
API レスポンスの `initiated_by` / `assigned_to` を UUID 文字列から `UserRef { id, name }` オブジェクトに変更し、全レイヤー（infra → core-service → BFF → Elm フロントエンド）を横断的に更新した。

## 背景と目的

ワークフロー詳細画面やタスク詳細画面で、申請者や担当者が UUID 文字列で表示されており、ユーザーにとって意味のある情報になっていなかった。ユーザー名を表示するために、バックエンドで ID → 名前の解決を行い、フロントエンドに渡す必要があった。

## 実施内容

5 Phase に分けて実装した。

| Phase | 内容 | 変更ファイル数 |
|-------|------|-------------|
| 1 | `UserRepository.find_by_ids` 追加 | 3 |
| 2 | Core Service DTO 変更 + ユーザー名解決 | 4 |
| 3 | BFF レスポンス型更新 | 4 |
| 4 | Elm フロントエンド更新 | 6 |
| 5 | OpenAPI 仕様書更新 + テスト修正 | 5 |

合計: 22 ファイル変更（+585 行 / -132 行）

## 設計上の判断

### ユーザー名解決の実装場所

当初はハンドラ層（CQRS の Query 側）に配置した。

理由:
- ユーザー名は「表示用の補足情報」であり、ドメインのビジネスロジック（状態遷移、権限検証）には不要
- ユースケース層に `UserRepository` を追加すると型パラメータが増え、全ハンドラ・ルーター・テストに波及する

→ ただし後続のレビューで「ハンドラから直接リポジトリを呼ぶのは割れ窓」と判断し、ユースケース層に移動した（後述「リファクタリング」セクション参照）。

### From トレイトの廃止

`From<DomainEntity>` トレイト実装を、ユーザー名マップを引数に取る明示的な変換関数に変更した。

理由:
- `From` トレイトは追加引数を受け取れない制約がある
- ユーザー名マップを渡すには関数シグネチャの変更が必要

### バッチ取得による N+1 回避

`UserRepository.find_by_ids` で `WHERE id = ANY($1)` を使い、ワークフロー内の全ユーザー ID を一括取得した。`HashSet` で ID を重複排除してからクエリを実行する。

## 成果物

コミット:
- `a26b322` #196 Resolve user names in workflow and task API responses
- `8691269` #196 Fix Hurl API tests for UserRef object response
- `44d074f` #196 Fix Hurl API tests for UserRef object response

PR: #197

関連 Issue:
- #198 人間向け表示用 ID（連番）の導入検討（将来課題として作成）

## 議論の経緯

### ID 表示の運用上の課題

ユーザーから、UUID を ID として運用する場合の課題が指摘された。口頭伝達・手入力が困難であり、エンタープライズシステムでは人間向け連番（例: `WF-1234`）の導入が望ましいという議論になった。今回のスコープ外だが、将来課題として Issue #198 を作成した。

### Hurl のオブジェクト比較の仕様

API テスト修正時に、Hurl のインライン JSON オブジェクト比較を推奨したが、実際には Hurl のプレディケート値ではインライン JSON オブジェクト内の変数展開がサポートされていなかった。公式ドキュメントを確認せずに推奨してしまい、CI を2回失敗させた。個別フィールド検証（`jsonpath "$.field.subfield"`）が正しいアプローチ。

## リファクタリング: UserRepository をユースケース層に移動

### 経緯

PR #197 のレビュー指摘対応後、「ハンドラから直接リポジトリを呼ぶ設計は問題ないのか」という議論が発生した。

結論: YAGNI/KISS と割れ窓理論は両立する。ハンドラ → リポジトリの直接呼び出しは小さな例外に見えるが、放置すると後続の実装で同じパターンが使われ、レイヤードアーキテクチャが崩れる。影響範囲の大きさ（型パラメータの追加）は正当なコストと判断した。

### 変更内容

| ファイル | 変更 |
|---------|------|
| `usecase.rs` | 共有 `resolve_user_names` 関数を追加 |
| `usecase/workflow.rs` | `WorkflowUseCaseImpl<D, I, S>` → `<D, I, S, U>`、`user_repo` フィールド追加、`collect_user_ids_from_workflow` を移動 |
| `usecase/task.rs` | `TaskUseCaseImpl<I, S>` → `<I, S, U>`、`user_repo` フィールド追加 |
| `handler/workflow.rs` | `WorkflowState` から `user_repository` 除去、ハンドラを `state.usecase.resolve_user_names(...)` に変更 |
| `handler/task.rs` | `TaskState` から `user_repository` 除去 |
| `main.rs` | `UserRepository` をユースケースのコンストラクタに渡す |

### 設計判断

- `resolve_user_names` の共有: 親モジュール `usecase.rs` に `pub(crate)` で配置し、各ユースケースのメソッドから委譲。コード重複を避けつつカプセル化を維持
- `collect_user_ids_from_workflow`: ドメインオブジェクトの操作なのでユースケース層に移動。ハンドラからは `crate::usecase::workflow::collect_user_ids_from_workflow(...)` で呼び出す
- `UserRefDto` / `to_user_ref`: DTO 変換はプレゼンテーション層の責務なのでハンドラに残留

## 学んだこと

- ツールの仕様は公式ドキュメントで確認してから提案すべき。「できそう」という推測で提案すると無駄な修正サイクルが発生する
- 型変更時はプロダクションコードだけでなく、テストフィクスチャ（Elm テストの JSON リテラル、Hurl のアサーション）も漏れなく更新する必要がある
- Hurl ではネストされたオブジェクトのフィールドに jsonpath でアクセスして個別に検証する
- YAGNI/KISS と割れ窓理論は両立する。「影響範囲が大きいからハンドラに置く」は正当化にならない。アーキテクチャの一貫性を保つコストは払うべき

## 次のステップ

- リファクタリングをコミット・プッシュ
- PR #197 のマージ
- 手動テストでユーザー名表示を確認
