# 2026-02-05 ドメインモデル非決定的値排除

## 概要

Issue #222: ドメインモデルから非決定的な値の生成（`Utc::now()` / `Uuid::now_v7()`）を排除し、呼び出し元から注入する形に変更した。Functional Core, Imperative Shell パターンの適用。API 変更なし・機能変更なしの純粋なリファクタリング。

## 背景と目的

ドメインモデル内部で `Utc::now()` や `Uuid::now_v7()` を直接呼び出していたため、テストで「特定の時刻で生成された場合の振る舞い」を検証できなかった。Functional Core, Imperative Shell パターンを適用し、ドメインモデルを純粋関数化する。

## 実施内容

2 Phase（エンティティ単位）に分割して実装した。

| Phase | 対象 | コミット |
|-------|------|---------|
| 1 | User + Role | `a6b7499` |
| 2a | WorkflowDefinition | `34c204a` |
| 2b | WorkflowInstance | `72bf82f` |
| 2c | WorkflowStep | `f662cfb` |

合計: 11 ファイル変更（+607 行 / -162 行）

### Phase 1: User + Role

- `User::new()` に `id: UserId` + `now: DateTime<Utc>` を追加
- `User::with_last_login_updated()`, `with_status()`, `deleted()` に `now` を追加
- `Role::new_system()`, `new_tenant()` に `id: RoleId` + `now` を追加
- `UserRole::new()` に `id: Uuid` + `now` を追加
- タイムスタンプ検証テストを追加

### Phase 2: Workflow

- `WorkflowDefinition::new()` に `id` + `now` を追加、`published()`, `archived()` に `now` を追加
- `WorkflowInstance::new()` に `id` + `now` を追加、7つの状態遷移メソッドに `now` を追加
- `WorkflowStep::new()` に `id` + `now` を追加、6つの状態遷移メソッド + `is_overdue()` に `now` を追加
- ユースケース層で `let now = chrono::Utc::now();` を取得し、全ドメイン操作に渡すパターンを適用
- テストコード（workflow, task, dashboard, infra テスト）の全呼び出し元を更新

## 設計上の判断

### `is_overdue()` への `now` 引数追加

`is_overdue()` は内部で `Utc::now()` を呼び出していた。テスタビリティと Functional Core の一貫性のため、`now: DateTime<Utc>` を引数で受ける形に変更した。

### ID 型の `new()` メソッド維持

`XxxId::new()` メソッド自体は削除せず、便利メソッドとして残した。エンティティのコンストラクタが外部から受け取る設計に変更しつつ、呼び出し元で `XxxId::new()` を使って ID を生成するパターンとした。

### `XxxId::from_uuid()` のバリデーション

`from_uuid()` は UUID バージョンのチェックを行わない。DB 復元や API パスパラメータなど、外部起源のデータを扱う用途のため、v4/v7 のバリデーションは不要と判断した。

### Clippy `too_many_arguments` への対応

`WorkflowInstance::new()` は `id` + `now` 追加で 9 引数になり、Clippy の上限（7）を超えた。`from_db()` と同様に `#[allow(clippy::too_many_arguments)]` を付与した。Builder パターンや構造体パラメータ化は過度な複雑化と判断。

## 成果物

コミット:

- `5ca9106` #222 WIP: Remove non-deterministic value generation from domain models
- `06a041d` #222 Add self-review verification section requirement for plan files
- `a6b7499` #222 Inject id and now into User and Role constructors
- `34c204a` #222 Inject id and now into WorkflowDefinition
- `72bf82f` #222 Inject id and now into WorkflowInstance
- `f662cfb` #222 Inject id and now into WorkflowStep

PR: [#228](https://github.com/ka2kama/ringiflow/pull/228)

## 議論の経緯

### UUID v4/v7 の保証箇所

`XxxId::new()` は `Uuid::now_v7()` を使用するが、`from_uuid()` は任意の UUID を受け入れる。ユーザーから「UUID バージョンの保証はどこで行うのか」と質問があった。

結論: 現状の設計で問題ない。`new()` が v7 を保証し、`from_uuid()` は外部データ復元用のため検証不要。型レベルで v7 を強制するのは過度な複雑化。

### リファクタリングの効果範囲

ユーザーから「このリファクタリングで結局何が改善されたのか」と質問があった。プロダクションコードで `XxxId::new()` を呼ぶのはユースケース層の 2 箇所のみ（`create_workflow` と `submit_workflow`）で、テストコードは便宜上 `XxxId::new()` を使い続けている。

結論: ドメインモデルの純粋性は達成された。タイムスタンプの注入が主要な改善点（テストで固定時刻を使った検証が可能に）。ID のテスト決定性は優先度が低い（テストで ID の一致を検証するケースは稀）。

## 学んだこと

- Functional Core, Imperative Shell パターンの適用: ドメインモデルから副作用（`Utc::now()`, `Uuid::now_v7()`）を排除し、呼び出し元から値を注入する。ユースケース層（Imperative Shell）がタイムスタンプと ID を生成する役割を担う
- シグネチャ変更の連鎖: Rust ではメソッドのシグネチャを変更すると全呼び出し元の同時更新が必要。エンティティ単位でコミットを分けることで差分を管理しやすくした
- `#[allow(clippy::too_many_arguments)]` は正当な場合がある: エンティティの全フィールドを受け取るコンストラクタでは、引数が多いのは構造的に避けられない場合がある

## 次のステップ

- PR #228 のレビュー・マージ
