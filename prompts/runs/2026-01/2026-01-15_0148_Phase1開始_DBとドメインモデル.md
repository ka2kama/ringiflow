# Phase 1 開始: データベーススキーマとドメインモデル実装

**日時**: 2026-01-15
**セッション**: 11

## 概要

Phase 0（基盤構築）の完了確認を行い、Phase 1（MVP開発）を開始した。
データベースマイグレーションファイル8つを作成・適用し、ドメインエンティティ（User, Role, Workflow）を実装した。
また、Phase 1実装のためのルールファイル（rust.md, repository.md）を追加した。

## 背景と目的

Phase 0の完了基準（cargo build, elm make, Docker Compose, ヘルスチェック, CI）をすべてクリアしたため、
Phase 1（MVP: 最小限の動作するワークフローシステム）の実装に移行する。

Phase 1の実装順序:
1. **DB スキーマ作成**（今回）
2. **Core API エンティティ実装**（今回）
3. Core API リポジトリ実装
4. Core API ユースケース実装
5. BFF 実装
6. Elm フロントエンド実装

## 実施内容

### 1. Phase 0 完了確認

以下の完了基準をすべてクリア:
- ✅ `cargo build` 成功
- ✅ `elm make` 成功
- ✅ Docker Compose で PostgreSQL/Redis が起動（healthy）
- ✅ ヘルスチェックエンドポイント `/health` が応答
- ✅ GitHub Actions で CI が通る

README.md を Phase 0 → Phase 1 に更新。

### 2. データベーススキーマ作成

`docs/02_設計書/02_データベース設計_MVP.md` に基づき、8つのマイグレーションファイルを作成:

| ファイル | 内容 |
|---------|------|
| `20260115000001_create_tenants.sql` | tenants テーブル、update_updated_at() 関数 |
| `20260115000002_create_users.sql` | users テーブル |
| `20260115000003_create_roles.sql` | roles テーブル |
| `20260115000004_create_user_roles.sql` | user_roles テーブル（多対多） |
| `20260115000005_create_workflow_definitions.sql` | workflow_definitions テーブル |
| `20260115000006_create_workflow_instances.sql` | workflow_instances テーブル |
| `20260115000007_create_workflow_steps.sql` | workflow_steps テーブル |
| `20260115000008_seed_system_data.sql` | システムロール、開発用テナント/ユーザー |

すべてのマイグレーションを適用し、動作確認済み:

```bash
cd apps/api && DATABASE_URL=postgres://ringiflow:ringiflow@localhost:5432/ringiflow_dev sqlx migrate run
# Applied 8 migrations successfully
```

### 3. ドメインモデル実装

`packages/domain/src/` に以下のエンティティを実装:

#### User エンティティ（`user.rs`）

- **UserId**: UUID v7 をラップした Newtype
- **Email**: バリデーション機能付き値オブジェクト（空文字列、@の有無、255文字制限）
- **UserStatus**: Active / Inactive / Deleted
- **User**: ユーザーエンティティ本体

ビジネスロジックメソッド:
- `is_active()` / `can_login()`: ステータスチェック
- `update_last_login()`: 最終ログイン日時更新
- `change_status()` / `delete()`: 状態変更

テスト: 11個のユニットテスト（すべて成功）

#### Role エンティティ（`role.rs`）

- **RoleId**: UUID v7 Newtype
- **Permission**: リソース:アクション形式（例: `workflow:read`, `*`）
- **Role**: システムロール / テナントロール
- **UserRole**: User と Role の多対多関連

権限チェック機能:
- `Permission::includes()`: 包含関係の判定（`workflow:*` は `workflow:read` を包含）
- `Role::has_permission()`: ロールが特定の権限を持つか判定
- `Role::can_delete()` / `can_edit()`: システムロールは削除・編集不可

テスト: 7個のユニットテスト（すべて成功）

#### Workflow エンティティ（`workflow.rs`）

3つのエンティティを実装:

**WorkflowDefinition（ワークフロー定義）**
- JSON 形式で定義を保持
- バージョン管理対応
- Draft / Published / Archived ステータス

**WorkflowInstance（ワークフローインスタンス）**
- 定義から生成された実行中の案件
- フォームデータを JSONB で保持
- Draft / Pending / InProgress / Approved / Rejected / Cancelled

**WorkflowStep（ワークフローステップ）**
- インスタンス内の各承認タスク
- 担当者への割り当て
- 承認/却下/修正依頼の判断

### 4. ルールファイル追加

Phase 1 実装のための2つのルールファイルを追加:

#### `rust.md`（6.6KB）

Rust 実装の品質基準:
- 型システムの活用（Newtype、Result 型、unwrap() 制限）
- エラーハンドリング（DomainError の使用）
- テスト要件（ドメインロジック、バリデーション、状態遷移）
- セキュリティ（入力検証、SQL インジェクション対策）

#### `repository.md`（7.8KB）

リポジトリ層の実装規約:
- SQLx クエリマクロの使用
- テナント分離の徹底（すべてのクエリに tenant_id）
- トランザクション管理
- N+1 問題の回避

## 成果物

### 作成ファイル

- マイグレーション: 8ファイル（`apps/api/migrations/202601150000*.sql`）
- ドメインモデル: 3ファイル（`packages/domain/src/{user,role,workflow}.rs`）
- ルール: 2ファイル（`.claude/rules/{rust,repository}.md`）

### 更新ファイル

- `README.md`: Phase 0 → Phase 1 に更新
- `packages/domain/Cargo.toml`: serde_json 依存追加
- `packages/domain/src/lib.rs`: 新モジュールを公開

### テスト結果

```
running 11 tests
test role::tests::test_permission_includes ... ok
test role::tests::test_role_has_permission ... ok
test role::tests::test_system_role_cannot_delete ... ok
test role::tests::test_permission_wildcard ... ok
test role::tests::test_tenant_role_can_delete ... ok
test role::tests::test_system_role_creation ... ok
test role::tests::test_tenant_role_creation ... ok
test user::tests::test_email_validation ... ok
test user::tests::test_user_creation ... ok
test user::tests::test_user_delete ... ok
test user::tests::test_user_status_change ... ok

test result: ok. 11 passed
```

## 設計判断と実装解説

### Newtype パターンによる型安全性

ID 型（UserId, RoleId など）は UUID をラップした Newtype で実装:

```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct UserId(Uuid);
```

**メリット:**
- コンパイル時に型の取り違えを検出（UserId と RoleId を間違えるとエラー）
- ゼロコスト抽象化（実行時オーバーヘッドなし）
- 明確な意図の表現

### 値オブジェクトによるバリデーション

Email や Permission は値オブジェクトとして実装し、生成時にバリデーションを実行:

```rust
impl Email {
    pub fn new(value: impl Into<String>) -> Result<Self, DomainError> {
        let value = value.into();
        if value.is_empty() {
            return Err(DomainError::Validation("メールアドレスは必須です".to_string()));
        }
        if !value.contains('@') {
            return Err(DomainError::Validation("メールアドレスの形式が不正です".to_string()));
        }
        // ...
        Ok(Self(value))
    }
}
```

**不正な状態を表現不可能にする（Make Illegal States Unrepresentable）**:
- 無効な Email インスタンスは存在しない
- 型システムで制約を保証
- バリデーション漏れを防ぐ

### エンティティの不変性とカプセル化

エンティティのフィールドは private にし、メソッド経由でのみアクセス:

```rust
pub struct User {
    id: UserId,           // private
    name: String,         // private
    status: UserStatus,   // private
    // ...
}

impl User {
    // Getter: 参照を返す
    pub fn id(&self) -> &UserId { &self.id }

    // 状態変更: メソッド経由
    pub fn change_status(&mut self, status: UserStatus) {
        self.status = status;
        self.updated_at = Utc::now();
    }
}
```

**不変条件の保護**:
- 外部から直接フィールドを変更できない
- ビジネスルールをメソッド内で強制（例: updated_at の自動更新）
- リファクタリングが容易

### 権限システムの柔軟性

Permission は文字列ベースで、ワイルドカード（`*`）や階層構造（`resource:action`）をサポート:

```rust
impl Permission {
    pub fn includes(&self, other: &Permission) -> bool {
        if self.is_wildcard() { return true; }  // "*" はすべてを包含
        if self.0 == other.0 { return true; }   // 完全一致

        // "workflow:*" は "workflow:read" を包含
        if let Some(resource) = self.0.strip_suffix(":*") {
            if let Some(other_resource) = other.0.split(':').next() {
                return resource == other_resource;
            }
        }
        false
    }
}
```

**拡張性**:
- システム管理者: `["*"]`
- テナント管理者: `["tenant:*", "user:*", "workflow:*"]`
- 一般ユーザー: `["workflow:read", "workflow:create"]`

将来的により複雑な権限モデルにも対応可能。

## 議論の経緯

Phase 0 が終わるかどうかの確認があり、次に何をするか説明した。Phase 0 の完了確認後、Phase 1 の DB スキーマ作成を開始する指示があった。

テストで pretty_assertions を使用するよう依頼があり、対応した。また、Phase 1 実装のためのルールファイルを追加するよう依頼があり、`rust.md` と `repository.md` を作成した。

## 学んだこと

### ドメイン層の設計

- **ビジネスロジックの中核をドメイン層に集約**: インフラや API 層に依存しない純粋なビジネスルールの表現
- **型で制約を表現**: 不正な状態をコンパイル時に排除し、実行時エラーを削減
- **値オブジェクトの活用**: バリデーションを生成時に実行し、以降は常に正しい値であることを保証

### Newtype パターンの威力

- UUID をそのまま使うと、UserId と RoleId を取り違える可能性がある
- Newtype で型を分けることで、コンパイラが誤用を検出
- 実行時のコストはゼロ（最適化で消える）

### テストの重要性

- ドメインロジックはテストしやすい（依存が少ない）
- `pretty_assertions` で差分が見やすくなる
- Arrange-Act-Assert パターンで可読性向上

## 次のステップ

Phase 1 の次のタスク:

1. **Core API リポジトリ実装**（データアクセス層）
   - SQLx を使用したリポジトリの実装
   - テナント分離の徹底（すべてのクエリに tenant_id）
   - トランザクション管理

2. **Core API ユースケース実装**（ビジネスロジック）
   - ユーザー登録・ログイン
   - ワークフロー作成・申請・承認

3. **BFF 実装**（セッション管理、認証、Core API プロキシ）

4. **Elm フロントエンド実装**

5. **結合テスト・動作確認**

6. **AWS デプロイ**

---

**関連ドキュメント**:
- [実装ロードマップ](../../docs/02_設計書/00_実装ロードマップ.md)
- [データベース設計（MVP）](../../docs/02_設計書/02_データベース設計_MVP.md)
- [Rust実装ルール](../../.claude/rules/rust.md)
- [リポジトリ層実装ルール](../../.claude/rules/repository.md)

**関連技術ノート**:
- [Newtype パターン](../../docs/05_技術ノート/Newtypeパターン.md)（新規作成）
- [ドメイン駆動設計エンティティ](../../docs/05_技術ノート/DDD_エンティティパターン.md)（新規作成）
- [sqlx-cli](../../docs/05_技術ノート/sqlx-cli.md)
