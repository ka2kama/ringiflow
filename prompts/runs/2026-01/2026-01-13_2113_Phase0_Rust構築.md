# 2026-01-13: Phase 0 Rust プロジェクト構築

## 概要

本セッションでは、RingiFlow プロジェクトの Phase 0「基盤構築」の続きとして、Rust プロジェクト構築を完了した。

## 背景と目的

前セッションでリポジトリ構造構築が完了し、次のステップとして Rust プロジェクト構築を実施する段階であった。

本セッションの目的は以下のとおりである。

- Cargo ワークスペースの設定
- 各クレート（shared, domain, infra, api）の作成
- ビルド・テストの動作確認

## 実施内容

### 1. Rust プロジェクト構築

Cargo ワークスペースを設定し、以下のクレートを作成した。

- packages/shared: 共有ユーティリティ（CorrelationId, datetime）
- packages/domain: ドメイン層（エラー定義、TenantId）
- packages/infra: インフラ層（DB/Redis 接続管理）
- apps/api: BFF/Core API サーバー（axum, ヘルスチェック）

モジュール構造は `mod.rs` を使用せず、新しい方式（`config.rs`、`handler.rs` + `handler/health.rs`）を採用した。

### 2. 設定の修正

以下の修正を実施した。

- Rust バージョンを 1.92.0 に変更
- edition を 2024 に変更
- redis クレートを 0.32 に更新
- cargo update で依存関係を最新化

## 成果物

### コミット

`Phase 0: Rust プロジェクト構築を完了`

### 作成ファイル

```
ringiflow/
├── Cargo.toml
├── apps/
│   └── api/
│       ├── .env.example
│       ├── Cargo.toml
│       └── src/
│           ├── lib.rs
│           ├── config.rs
│           ├── error.rs
│           ├── handler.rs
│           ├── handler/
│           │   └── health.rs
│           └── bin/
│               ├── bff.rs
│               └── core_api.rs
└── packages/
    ├── domain/
    ├── infra/
    └── shared/
```

## 設計判断と実装解説

本セクションでは、生成した Rust コードの設計判断とその背景を解説する。

### 1. Cargo ワークスペース構成

**採用した構成**:

```toml
[workspace]
resolver = "2"
members = [
    "apps/api",
    "packages/domain",
    "packages/infra",
    "packages/shared",
]
```

**意図**: モノレポ構成により、複数クレートを単一リポジトリで管理する。`apps/` にはアプリケーション（実行可能バイナリ）、`packages/` には共有ライブラリを配置し、責務を明確に分離する。

**代替案と不採用理由**:

| 代替案 | 不採用理由 |
|--------|-----------|
| マルチリポジトリ | 学習目的では全体を把握しにくい。依存関係のバージョン管理が複雑化する |
| 単一クレート | コードが肥大化し、コンパイル時間が増加する。責務の分離が曖昧になる |

**トレードオフ**: ワークスペース構成は初期設定が複雑になるが、長期的にはビルドキャッシュの共有やリファクタリングの容易さで利点がある。

### 2. レイヤー構造（shared → domain → infra → api）

**採用した依存関係**:

```
api → infra → domain → shared
         ↘      ↓
           shared
```

**意図**: クリーンアーキテクチャに基づき、依存関係を内側（ドメイン）から外側（インフラ）への一方向に制限する。これにより、ビジネスロジックが外部技術（DB、Redis）に依存しない設計となる。

**各レイヤーの責務**:

| レイヤー | 責務 | 依存先 |
|---------|------|--------|
| shared | 全レイヤー共通のユーティリティ | なし |
| domain | エンティティ、値オブジェクト、ドメインサービス | shared |
| infra | リポジトリ実装、外部サービスクライアント | domain, shared |
| api | HTTP ハンドラ、ルーティング、設定 | infra, domain, shared |

**関連知識**: この構成は「ヘキサゴナルアーキテクチャ」「オニオンアーキテクチャ」とも呼ばれる。ドメイン層がインフラ層に依存しないため、テスト時にモックを差し替えやすい。

### 3. Newtype パターン（CorrelationId, TenantId）

**採用したコード**:

```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct CorrelationId(String);

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TenantId(Uuid);
```

**意図**: プリミティブ型（String, Uuid）をラップすることで、型安全性を確保する。これにより、`CorrelationId` と `TenantId` を取り違えるバグをコンパイル時に検出できる。

**代替案と不採用理由**:

| 代替案 | 不採用理由 |
|--------|-----------|
| 型エイリアス（`type TenantId = Uuid`） | コンパイル時に区別されない。取り違えを検出できない |
| マクロによる自動生成 | 学習目的では明示的な実装が理解しやすい |

**トレードオフ**: Newtype パターンは安全だが、内部値へのアクセスに `as_str()` や `as_uuid()` メソッドが必要となる。これは意図的な設計であり、不用意な型変換を防ぐ。

**関連知識**: Rust の Newtype パターンはゼロコスト抽象化であり、コンパイル後のバイナリでは追加のオーバーヘッドが発生しない。

### 4. エラーハンドリング（thiserror + anyhow）

**採用したコード**:

```rust
#[derive(Debug, Error)]
pub enum DomainError {
    #[error("バリデーションエラー: {0}")]
    Validation(String),

    #[error("{entity_type} が見つかりません: {id}")]
    NotFound { entity_type: &'static str, id: String },
    // ...
}
```

**意図**: `thiserror` でカスタムエラー型を定義し、`anyhow` でエラーの伝播を簡略化する。ドメイン層とインフラ層では具体的なエラー型を使用し、アプリケーション層では `anyhow::Error` で統一的に扱う。

**使い分け**:

| クレート | 用途 | 使用箇所 |
|---------|------|---------|
| thiserror | 公開 API のエラー型定義 | domain, api (ApiError) |
| anyhow | 内部エラーの伝播、エラーチェイン | api (main, handler) |

**代替案と不採用理由**:

| 代替案 | 不採用理由 |
|--------|-----------|
| 標準ライブラリのみ | ボイラープレートが多く、エラーメッセージの生成が煩雑 |
| eyre | anyhow と同等だが、thiserror との組み合わせでは anyhow が一般的 |

### 5. axum ルーター構成

**採用したコード**:

```rust
let app = Router::new()
    .route("/health", get(health_check))
    .layer(TraceLayer::new_for_http());
```

**意図**: axum のルーターは宣言的に構築でき、ミドルウェア（layer）を柔軟に追加できる。`TraceLayer` により、すべての HTTP リクエストがトレーシングされる。

**設計方針**:

- ルート定義は `Router::new().route()` でチェーン
- ミドルウェアは `.layer()` で追加
- 状態共有は `Extension` または `State` エクストラクタを使用（Phase 1 で実装予定）

**関連知識**: axum は tower エコシステムの一部であり、`tower::Service` トレイトを基盤としている。これにより、tower-http のミドルウェア（CORS、圧縮、認証など）を直接利用できる。

### 6. モジュール構造（mod.rs を使用しない方式）

**採用した構造**:

```
src/
├── lib.rs
├── config.rs           # config モジュール
├── error.rs            # error モジュール
├── handler.rs          # handler モジュールの宣言
└── handler/
    └── health.rs       # handler::health サブモジュール
```

**意図**: Rust 2018 edition 以降で推奨される方式を採用。`mod.rs` を使用する従来方式と比べ、ファイル名からモジュール名が明確にわかる。

**従来方式との比較**:

| 方式 | ファイル構成 | 特徴 |
|------|-------------|------|
| 従来（mod.rs） | `handler/mod.rs`, `handler/health.rs` | エディタで複数の mod.rs が開かれると混乱しやすい |
| 新方式 | `handler.rs`, `handler/health.rs` | ファイル名とモジュール名が一致し、可読性が高い |

**handler.rs の内容**:

```rust
pub mod health;
pub use health::health_check;
```

親モジュールでサブモジュールを宣言し、公開 API を re-export する。

### 7. 設定管理（環境変数からの読み込み）

**採用したコード**:

```rust
impl AppConfig {
    pub fn from_env() -> Result<Self, env::VarError> {
        Ok(Self {
            server: ServerConfig {
                host: env::var("BFF_HOST").unwrap_or_else(|_| "0.0.0.0".to_string()),
                port: env::var("BFF_PORT")
                    .unwrap_or_else(|_| "3000".to_string())
                    .parse()
                    .unwrap_or(3000),
            },
            // ...
        })
    }
}
```

**意図**: 12-Factor App の原則に従い、設定を環境変数から読み込む。デフォルト値を提供することで、開発環境での起動を簡略化する。

**代替案と不採用理由**:

| 代替案 | 不採用理由 |
|--------|-----------|
| config クレート | Phase 0 では過剰。TOML/YAML ファイルのパースは Phase 1 以降で検討 |
| figment クレート | 高機能だが学習コストが高い。シンプルな環境変数読み込みで十分 |

**トレードオフ**: 現在の実装は `DATABASE_URL` が未設定の場合にパニックする。本番環境では、起動時にすべての必須設定を検証し、明確なエラーメッセージを表示すべきである（Phase 1 で改善予定）。

## 議論の経緯

ユーザーから Rust のバージョンを 1.92.0 に更新し、各種ライブラリも最新安定版にするよう依頼があった。また、cargo update で依存関係を最新化し、edition は 2024 を使用するよう指示があった。

モジュール構造について、mod.rs を使用しない新しい方式に修正するよう依頼があり、対応した。

## 次のステップ

Phase 0 の残りの作業を継続する。

- Elm プロジェクト構築（elm.json、Vite 設定）
- Docker 環境構築（docker-compose.yml）
- CI/CD 構築（GitHub Actions）
- Terraform 基盤構築（モジュール構造）
