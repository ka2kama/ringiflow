# 2026-01-14: Phase 0 Elm プロジェクト構築

## 概要

本セッションでは、RingiFlow プロジェクトの Phase 0「基盤構築」の続きとして、Elm フロントエンドプロジェクトを構築した。また、フロントエンドツールチェーンの選定に関する ADR を作成し、手順書を更新した。

## 背景と目的

前回のセッションで Rust プロジェクト構築が完了し、次のステップとして Elm プロジェクト構築を実施する段階であった。

本セッションの目的は以下のとおりである。

- Elm + Vite によるフロントエンドプロジェクトの構築
- ビルド・テストの動作確認
- 技術選定の理由を ADR として記録

## 実施内容

### 1. 手順書の確認

`docs/03_手順書/04_Elmプロジェクト構築.md` に従い、プロジェクト構築を開始した。

### 2. プロジェクトファイルの作成

以下のファイルを作成した。

- `apps/web/package.json` - Node.js パッケージ設定
- `apps/web/elm.json` - Elm パッケージ設定
- `apps/web/vite.config.js` - Vite ビルド設定
- `apps/web/index.html` - HTML テンプレート
- `apps/web/src/main.js` - JavaScript エントリポイント
- `apps/web/src/Main.elm` - Elm メインモジュール
- `apps/web/src/Route.elm` - ルーティングモジュール
- `apps/web/src/Ports.elm` - JavaScript 連携モジュール
- `apps/web/tests/Example.elm` - テストファイル
- `apps/web/.env.example` - 環境変数テンプレート
- `apps/web/.gitignore` - Git 除外設定

### 3. パッケージマネージャーの問題と解決

当初の手順書では Bun を使用する想定だったが、以下の問題が発生した。

**問題 1: elm-test と Node.js/Bun の互換性**

elm-test は古い JavaScript の書き方（グローバル変数への代入）を使用しており、Node.js v24 および Bun の strict mode と互換性がなかった。

**問題 2: pnpm と elm ネイティブバイナリの非互換**

elm npm パッケージはネイティブバイナリを配布するが、pnpm は `node_modules/.bin/` にシムスクリプトを生成し、すべてのコマンドを Node.js 経由で実行しようとする。これによりネイティブバイナリが実行できなかった。

**解決策**

プロジェクトの理念（暗黙知ゼロ、学習支援）に照らし合わせ、以下の構成を採用した。

- elm, elm-format, elm-test: グローバルインストール（npm）
- vite, vite-plugin-elm: ローカルインストール（pnpm）
- Node.js: Volta でバージョン管理（v20 LTS）

この決定を ADR として記録した。

### 4. ADR の作成

`docs/04_ADR/002_フロントエンドツールチェーンの選定.md` を作成し、以下を記録した。

- コンテキスト: elm npm パッケージのネイティブバイナリ配布の特性
- 検討した選択肢: npm、pnpm、Bun、グローバル + ローカル
- 決定: elm 系はグローバル、ビルドツールはローカル
- 帰結: パッケージマネージャー非依存、バージョン管理は mise/Volta で対応

### 5. 手順書の更新

以下の手順書を更新した。

**01_開発環境構築.md**
- Bun → Node.js + pnpm に変更
- Elm グローバルインストールの理由を明記
- ADR への参照を追加

**04_Elmプロジェクト構築.md**
- bun → pnpm にコマンドを変更
- devDependencies から elm, elm-test を削除
- pnpm-lock.yaml をバージョン管理に含める説明を追加

### 6. ビルド・テスト確認

以下のコマンドが正常に動作することを確認した。

```bash
pnpm install     # 依存関係インストール
pnpm run build   # 本番ビルド（vite build）
pnpm run test    # テスト実行（elm-test）
```

### 7. 不要ファイルの整理

以下の不要ファイルを削除した。

- `bun.lock` - Bun のロックファイル
- `pnpm-workspace.yaml` - apps/web には不要
- `public/` - 未使用の空ディレクトリ

## 成果物

### コミット

`Phase 0: Elm プロジェクト構築を完了`

### 作成ファイル

```
apps/web/
├── src/
│   ├── Main.elm
│   ├── Route.elm
│   ├── Ports.elm
│   ├── main.js
│   └── Page/.gitkeep
├── tests/
│   └── Example.elm
├── index.html
├── elm.json
├── package.json
├── pnpm-lock.yaml
├── vite.config.js
├── .env.example
└── .gitignore
```

### 更新ファイル

- `docs/03_手順書/01_開発環境構築.md`
- `docs/03_手順書/04_Elmプロジェクト構築.md`
- `docs/04_ADR/README.md`

### 新規 ADR

- `docs/04_ADR/002_フロントエンドツールチェーンの選定.md`

## 設計判断と実装解説

### 1. elm のグローバルインストール

**採用した構成**:

```bash
# グローバル（開発環境セットアップ時）
npm install -g elm elm-format elm-test

# ローカル（プロジェクト）
pnpm install  # vite, vite-plugin-elm のみ
```

**意図**: elm npm パッケージはネイティブバイナリを配布する特殊なパッケージである。pnpm はすべての bin エントリを Node.js シムスクリプト経由で実行しようとするため、ネイティブバイナリと非互換である。グローバルインストールによりこの問題を回避する。

**代替案と不採用理由**:

| 代替案 | 不採用理由 |
|--------|-----------|
| npm でローカルインストール | pnpm より遅く、ディスク効率が低い |
| Bun でローカルインストール | 動作するが、エコシステムの成熟度で npm に劣る |
| elm-test-rs を使用 | 信頼性の観点で公式 elm-test を優先 |

**トレードオフ**: グローバルツールのバージョン管理が必要になるが、mise や Volta で対応可能。package.json だけでは elm のバージョンが明示されないため、手順書に明記した。

### 2. Volta による Node.js バージョン管理

**採用した設定**:

```json
{
  "volta": {
    "node": "20.20.0"
  }
}
```

**意図**: Volta は package.json に Node.js バージョンを記載することで、プロジェクト単位でバージョンを固定できる。これにより、チームメンバー間で Node.js バージョンの不一致を防ぐ。

**関連知識**: Volta は Rust 製のツールで、高速かつクロスプラットフォームで動作する。fnm や nvm と異なり、シェルフックに依存せずバージョン切り替えが行われる。

### 3. pnpm-lock.yaml のバージョン管理

**採用した方針**: pnpm-lock.yaml を .gitignore に含めず、バージョン管理する。

**意図**: ロックファイルは依存関係の正確なバージョンを記録し、再現可能なビルドを保証する。CI 環境や他の開発者が同じ依存関係でビルドできるようにするため、バージョン管理に含める。

**注意**: 当初の手順書では pnpm-lock.yaml を .gitignore に含める記載があったが、これを修正した。

### 4. Elm アプリケーション構造（TEA）

**採用した構造**:

```elm
main : Program Flags Model Msg
main =
    Browser.application
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        , onUrlChange = UrlChanged
        , onUrlRequest = LinkClicked
        }
```

**意図**: The Elm Architecture (TEA) に従い、Model-Update-View の分離を徹底する。Browser.application を使用することで、URL ベースのルーティングとブラウザ履歴の管理が可能になる。

**関連知識**: TEA は Redux の設計に影響を与えたアーキテクチャパターンである。単方向データフローにより、状態管理が予測可能になる。

### 5. Ports 設計

**採用した設計**:

```elm
port sendMessage : Encode.Value -> Cmd msg
port receiveMessage : (Encode.Value -> msg) -> Sub msg
```

**意図**: Elm と JavaScript の境界を明確にし、型安全な通信を実現する。JSON.Encode.Value を使用することで、任意のデータ構造を送受信できる。

**関連知識**: Elm の Ports は意図的に制限されており、JavaScript 側で発生したエラーが Elm 側に伝播しない。これにより「ランタイムエラーなし」の保証を維持する。

## 議論の経緯

### パッケージマネージャーの選定

設計書には Bun を使用すると記載されていたが、ユーザーから pnpm を使用するよう指示があった。elm npm パッケージとの互換性問題が発生したため、要件定義書や設計書に記載されたプロジェクトの理念・目的に最も合致する選択肢を検討した。

最終的に「elm 系はグローバル、ビルドツールはローカル」という構成を採用し、設計書と ADR を更新した。

### クリーンアップ

不要なファイルやディレクトリの整理について確認があった。node_modules ディレクトリの存在についても確認があり、package.json など各種設定ファイルの内容も問題がないか確認した。

## 学んだこと

### npm パッケージのネイティブバイナリ配布

elm のような npm パッケージはネイティブバイナリを配布しており、postinstall スクリプトで OS/アーキテクチャに応じたバイナリをダウンロードする。パッケージマネージャーによって bin エントリの扱いが異なるため、互換性の問題が発生することがある。

### 暗黙知ゼロの実践

技術的な問題に遭遇した際、単に回避策を適用するのではなく、「なぜその問題が発生したか」「なぜその解決策を選んだか」を ADR として記録することで、暗黙知を排除できる。

---

## 追加セッション: 詳細解説の追加

### 背景

RingiFlow の理念「暗黙知ゼロ」「学習支援」に基づき、追加したコードやファイルに詳細な解説を追加する依頼があった。

### 実施内容

#### 1. Elm ソースファイルへの解説追加

各 Elm ファイルに doc comment（`{-| ... -}`）形式で解説を追加した。

| ファイル | 追加した解説内容 |
|---------|---------------|
| `Main.elm` | TEA パターンの概要、Browser.application を選択した理由、代替案（elm-spa 等）の不採用理由、Model/Update/View/Flags の設計意図 |
| `Route.elm` | URL パーサーコンビネータの仕組み、カスタム型の設計意図、fromUrl/toString の双方向性 |
| `Ports.elm` | Ports の設計思想（エラー非伝播等）、メッセージフォーマットの推奨構造、使用例コード |
| `tests/Example.elm` | elm-test の構造、なぜルーティングをテストするか、将来の Fuzzing/View テストの拡張例 |

#### 2. JavaScript/設定ファイルへの解説追加

| ファイル | 追加した解説内容 |
|---------|---------------|
| `main.js` | Elm 初期化の流れ、Flags の各フィールドの用途、Vite 環境変数の扱い、Ports 使用例 |
| `vite.config.js` | Vite を選択した理由（Webpack 等との比較）、API プロキシの設計意図、ビルド設定 |

#### 3. README.md の作成

`apps/web/README.md` を新規作成し、以下を記載した。

- ディレクトリ構造とコマンド一覧
- `elm.json` の各フィールド解説（依存パッケージの役割）
- `package.json` の各フィールド解説
- `index.html` の設計ポイント
- `.env.example` と `.gitignore` の説明
- TEA アーキテクチャ図とデータフロー図

#### 4. JSON ファイルのコメントについて

`package.json` と `elm.json` は標準 JSON のみサポートしており、JSONC や JSON5 でコメントを追加することはできない。

| ファイル | JSONC | JSON5 | 理由 |
|---------|-------|-------|------|
| package.json | 不可 | 不可 | npm 仕様で標準 JSON のみ |
| elm.json | 不可 | 不可 | Elm コンパイラが標準 JSON のみ対応 + `elm install` で上書きされる |

そのため、README.md に解説を記載する形を採用した。

#### 5. クリーンアップ

以下のディレクトリを削除してクリーンな状態にした。

- `node_modules/` - 不要な elm パッケージが混入していたため削除し `pnpm install` で再生成
- `dist/` - ビルド出力（`pnpm run build` で再生成可能）
- `elm-stuff/` - Elm コンパイラキャッシュ（elm 実行時に再生成）

### 成果物

#### コミット

`Elm プロジェクトに詳細な解説コメントを追加`

#### 更新ファイル

- `apps/web/src/Main.elm` - TEA パターンの詳細解説
- `apps/web/src/Route.elm` - URL パーサーの解説
- `apps/web/src/Ports.elm` - JavaScript 連携の解説
- `apps/web/src/main.js` - Elm 初期化の解説
- `apps/web/vite.config.js` - ビルド設定の解説
- `apps/web/tests/Example.elm` - テスト設計の解説

#### 新規ファイル

- `apps/web/README.md` - 設定ファイル解説とアーキテクチャ図

### 議論の経緯

#### 詳細解説の追加

RingiFlow の理念と目的に則り、追加したコードやファイルに詳細な解説を追加するよう依頼があった。

#### JSON ファイルのコメント

package.json や elm.json を JSONC や JSON5 形式で記述できないかという質問があり、両ファイルとも標準 JSON のみサポートしていることを説明した。

#### pnpm v10 のセキュリティ機能

pnpm approve-builds コマンドについて質問があり、pnpm v10 から追加されたセキュリティ機能であることを説明した。

#### IDE 設定の問題

IntelliJ の Elm プラグインで Lamdera バイナリのエラーが発生し、.elm ファイルで型が検出されない問題が報告された。Lamdera path に ~/.volta/bin/elm を設定したら動作したとのことで、なぜ動作するかの説明と手順書への追記を行った。

### 学んだこと

#### Elm の doc comment

Elm の doc comment は `{-| ... -}` 形式で記述する。これは IDE でのホバー表示や `elm-doc-preview` での API ドキュメント生成に使用される。モジュールレベルのコメントはモジュール宣言の直後に配置する。

#### pnpm v10 のセキュリティ機能

pnpm v10 から `pnpm approve-builds` コマンドが追加された。セキュリティ強化のため、パッケージの postinstall スクリプトがデフォルトで実行されなくなり、明示的な許可が必要になった。

#### IntelliJ Elm プラグインの Lamdera 設定

IntelliJ の Elm プラグインは Lamdera path が空だとエラーになる場合がある。RingiFlow では Lamdera を使用しないが、回避策として Lamdera path に elm バイナリのパスを設定することで動作する。

#### elm-stuff と型検出

IntelliJ の Elm プラグインが型情報を検出するには elm-stuff ディレクトリが必要。`elm make` を実行して elm-stuff を生成した後、IDE のキャッシュをクリア（Invalidate Caches）すると認識される。

---

## 次のステップ

Phase 0 の残りの作業を継続する。

- Docker 環境構築（docker-compose.yml）
- CI/CD 構築（GitHub Actions）
- Terraform 基盤構築（モジュール構造）
