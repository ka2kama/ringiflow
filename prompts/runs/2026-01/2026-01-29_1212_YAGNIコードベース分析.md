# YAGNI コードベース分析

## 日時

2026-01-29

## 概要

「YAGNI の適用範囲と構造劣化のリスク」について議論し、RingiFlow コードベースに対して YAGNI 観点の分析を実施した。未使用コード・過剰な先行実装・構造劣化の検出メカニズムの欠如を特定した。

## 背景

- YAGNI は「機能」に対する原則であり、「設計」に対しては慎重に適用すべき
- 「後から自然にリストラクチャリングする」という前提は、人間にも AI エージェントにも構造的に困難
- RingiFlow 自身にも「よくない YAGNI」がないか自己点検を実施

## 分析結果

### 発見された問題

#### 1. `ringiflow-shared` クレート — 完全に未使用

5 つのクレート（`domain`, `infra`, `bff`, `core-service`, `auth-service`）が `Cargo.toml` で依存しているが、`use ringiflow_shared` が実コード中に一度も出現しない（doc コメント内のみ）。

| モジュール | 内容 | 使用箇所 |
|-----------|------|---------|
| `correlation_id.rs` | リクエスト追跡用 ID（115行 + テスト4本） | ゼロ |
| `datetime.rs` | `Utc::now()` のラッパー（37行） | ゼロ |

問題点:
- 5 クレートが依存宣言しているため、ビルドグラフに無意味な結合が発生
- `datetime::now()` は「将来 Clock トレイトを導入するかも」というコメントがあるが、現時点では `Utc::now()` と等価
- `CorrelationId` はミドルウェアでのリクエスト伝播がなければ意味がない

#### 2. `Role`/`Permission` — 丁寧に実装されたが使われないビジネスロジック

`Role` の構造体自体は使われている（API レスポンスへの変換、DB からの読み出し）。しかしビジネスロジックのメソッド群はアプリケーション層から一切呼ばれていない:

| メソッド | 定義箇所 | apps/ での呼び出し |
|---------|---------|-------------------|
| `has_permission()` | `role.rs:281` | ゼロ |
| `can_delete()` | `role.rs:288` | ゼロ |
| `can_edit()` | `role.rs:300` | ゼロ |
| `with_permissions()` | `role.rs:310` | ゼロ |

`Permission::includes()` のワイルドカードマッチング（`workflow:*` → `workflow:read`）も同様に未使用。

問題点:
- テスト対象のロジックが本番で動いていない（テスト自体の価値が限定的）
- RBAC は「認可アーキテクチャ」として先行設計が必要な領域だが、「モデルだけ作って組み込まないまま放置」は最も危険な状態
- 実際の要件とのズレが検出されないまま先に進むリスク

#### 3. 構造劣化の検出メカニズムが不在

RingiFlow には ADR の「再検討トリガー」や改善記録のフィードバックループなど、優れた防御策がある。しかし「構造が劣化し始めたこと」を検出する仕組みが欠けている:

| 存在する防御策 | 欠けている防御策 |
|-------------|--------------|
| ADR の再検討トリガー（意図の揮発を防ぐ） | ファイルサイズ・複雑度の閾値アラート |
| `.claude/rules/` の必須チェック（漏れやすい操作を防御） | 未使用コードの定期検出 |
| 改善記録のフィードバックループ（AI の行動を改善） | モジュール間結合度の監視 |

### YAGNI 判断フレームワーク

分析を通じて以下の判断基準を整理した:

```
                後から修正するコスト
                低い          高い
漏れの    低  ✅ YAGNI で     ⚠️ 軽い
リスク        後回し         先行投資

          高  ⚠️ ルールで    🔴 先行設計
              防御          が必須
```

| カテゴリ | 例 | 対策 |
|---------|-----|------|
| 先行設計が必須 | データモデル、サービス境界、認可アーキテクチャ | 最初から慎重に設計 |
| ルールで防御 | 命名規則、テスト欠落 | CI / lint で機械的に検出 |
| YAGNI で後回し | ユーティリティ関数、UI コンポーネント分割 | 必要になった時に作る |

### 自己矛盾の発見

CLAUDE.md に「3回繰り返すまでは重複を許容」と書いてあるが、`ringiflow-shared` の `CorrelationId` や `datetime::now()` は 0 回の使用段階で抽象化されている。

## 次のアクション

1. [x] GitHub Issue: `ringiflow-shared` の未使用コード整理 → [#149](https://github.com/ka2kama/ringiflow/issues/149)
2. [x] GitHub Issue: `Role`/`Permission` の未使用ビジネスロジック整理 → [#150](https://github.com/ka2kama/ringiflow/issues/150)
3. [x] GitHub Issue: 構造劣化の検出メカニズム導入 → [#151](https://github.com/ka2kama/ringiflow/issues/151)

## 学んだこと

- YAGNI の「正しい適用範囲」は可逆性のコストと漏れのリスクで判断すべき
- 「先行投資すべき領域（データモデル・認可）」と「後回しでよい領域（ユーティリティ）」は明確に区別できる
- Claude Code は「パターン追従バイアス」と「セッション境界の壁」により、自発的なリストラクチャリングが構造的に困難
- RingiFlow の ADR 再検討トリガーや改善記録は優れた防御策だが、「構造劣化の検出」が欠けている
