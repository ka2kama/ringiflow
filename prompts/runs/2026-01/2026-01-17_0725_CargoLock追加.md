# Cargo.lock をバージョン管理対象に追加

## 概要

アプリケーションプロジェクトにおけるビルドの再現性を確保するため、
`Cargo.lock` を `.gitignore` から削除し、バージョン管理対象に追加した。

## 背景と目的

`.gitignore` に `Cargo.lock` が含まれていたが、これはライブラリ向けの設定。
RingiFlow は SaaS アプリケーション（エンドプロダクト）であり、
ビルドの再現性を保証するため `Cargo.lock` をコミットすべきである。

## 実施内容

1. `.gitignore` から `Cargo.lock` のエントリと関連コメントを削除
2. `backend/Cargo.lock` をバージョン管理対象に追加
3. 技術ノート「Cargoワークスペース.md」に Cargo.lock の管理方針を追記

## 成果物

| 種類 | ファイル |
|------|---------|
| 変更 | `.gitignore` |
| 追加 | `backend/Cargo.lock` |
| 更新 | `docs/06_技術ノート/Cargoワークスペース.md` |

## 設計判断と実装解説

### アプリケーション vs ライブラリ

| プロジェクト種別 | Cargo.lock | 理由 |
|-----------------|------------|------|
| アプリケーション | コミットする | ビルドの再現性を保証 |
| ライブラリ | gitignore | 利用者の依存解決を妨げない |

**アプリケーションでコミットする理由:**
- 全開発者が同じ依存バージョンでビルドできる
- CI の安定性（ビルドのたびに依存が変わらない）
- セキュリティ監査（どのバージョンを使っているか追跡可能）
- デプロイの信頼性（本番環境で予期しない依存更新が起きない）

**ライブラリで含めない理由:**
- ライブラリは他のプロジェクトの依存として使われる
- `Cargo.lock` をコミットしても利用者側では無視される
- 開発時に古いバージョンに固定され、互換性テストの妨げになる

Cargo Book でも同様の指針が示されている:
> If you're building a non-end product, such as a rust library that other rust
> packages will depend on, put `Cargo.lock` in your `.gitignore`.

## 議論の経緯

### Cargo.lock の管理方針

ユーザーから `Cargo.lock` を gitignore に含めるべきかどうかという質問があった。プロジェクトの性質（SaaS アプリケーション）を考慮し、ビルドの再現性を保証するためコミットすべきという結論に至った。

## 学んだこと

- プロジェクトの性質（アプリケーション vs ライブラリ）によって、ロックファイルの扱いが異なる
- ロックファイルの目的は「再現性の保証」であり、アプリケーションでは重要
