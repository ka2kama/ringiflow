# Phase 7: CSRF トークン実装

## 概要

CSRF（Cross-Site Request Forgery）防御機能を実装した。ログイン時に CSRF トークンを自動生成し、状態変更リクエスト（POST/PUT/PATCH/DELETE）で検証する。また、CSRF に関する技術ノートを作成した。

## 背景と目的

認証機能の最終フェーズとして、CSRF 攻撃からの保護が必要だった。設計書で定義された Double Submit Cookie パターンを実装し、SameSite Cookie との多層防御を実現した。

## 実施内容

### 1. SessionManager トレイト拡張

CSRF トークン管理用のメソッドを追加:

- `create_csrf_token`: トークン生成（64 文字 hex）
- `get_csrf_token`: トークン取得
- `delete_csrf_token`: トークン削除
- `delete_all_csrf_for_tenant`: テナント単位削除

### 2. CSRF 検証ミドルウェア

`middleware/csrf.rs` を新規作成:

- POST/PUT/PATCH/DELETE で `X-CSRF-Token` ヘッダーを検証
- `/auth/login`, `/auth/csrf`, `/health` はスキップ
- `CsrfState` と `AuthState` を分離（依存の最小化）

### 3. ハンドラ修正

- ログイン時: セッション作成後に CSRF トークンを自動生成
- ログアウト時: CSRF トークンを削除（失敗は無視、TTL で自動削除）

### 4. 統合テスト追加

6 件の CSRF 関連テストを追加:

- トークン生成・取得・検証
- トークンなし/不正トークンで 403
- ログアウト時の削除確認

### 5. 技術ノート作成

`docs/06_技術ノート/CSRF.md` を作成:

- CSRF 攻撃の仕組み
- 同一オリジンポリシーとの関係
- オリジン偽装が不可能な理由
- ブラウザ脆弱性と多層防御
- 防御方法の比較（SameSite, CSRF トークン, Double Submit Cookie）

## 成果物

### 作成したファイル

| ファイル | 内容 |
|---------|------|
| `backend/apps/bff/src/middleware.rs` | ミドルウェアモジュール |
| `backend/apps/bff/src/middleware/csrf.rs` | CSRF 検証ミドルウェア |
| `docs/06_技術ノート/CSRF.md` | CSRF 技術ノート |
| `docs/07_実装解説/01_認証機能/07_Phase7_CSRFトークン.md` | 実装解説 |

### 更新したファイル

| ファイル | 変更内容 |
|---------|---------|
| `backend/crates/infra/src/session.rs` | CSRF メソッド追加、Clone 導出 |
| `backend/apps/bff/src/handler/auth.rs` | ログイン/ログアウト時の CSRF 処理 |
| `backend/apps/bff/src/main.rs` | CSRF ミドルウェア統合 |
| `backend/apps/bff/tests/auth_integration_test.rs` | CSRF テスト追加 |
| `docs/03_詳細設計書/07_認証機能設計.md` | SessionManager インターフェース更新 |

## 設計判断と実装解説

### CsrfState と AuthState の分離

CSRF ミドルウェアは `SessionManager` のみ必要で、`CoreApiClient` は不要。依存を最小化するため、別の状態型を定義した。

```rust
// CsrfState は SessionManager のみ
pub struct CsrfState<S: SessionManager + Clone> {
    pub session_manager: S,
}

// AuthState は CoreApiClient + SessionManager
pub struct AuthState<C: CoreApiClient, S: SessionManager> {
    pub core_api_client: C,
    pub session_manager: S,
}
```

### エラーハンドリングの非対称性

| 操作 | 失敗時の対応 | 理由 |
|------|------------|------|
| 作成（ログイン時） | 500 エラーを返す | CSRF 防御が機能しなくなる |
| 削除（ログアウト時） | 警告ログのみ、処理続行 | TTL で自動削除される |

## 議論の経緯

### 同一オリジンポリシーの理解

ユーザーから、同一オリジンポリシーでブロックされるという説明がよくわからないという質問があった。レスポンスの読み取りがブロックされるがリクエスト送信自体はブロックされない点を詳細に説明した。

### オリジン偽装の可否

同一オリジンになりすますことはできないのかという質問があった。Origin ヘッダーはブラウザが自動設定する「禁止ヘッダー」であり、JavaScript から偽装不可であることを説明した。

### ブラウザ脆弱性を想定したケース

ブラウザに脆弱性があった場合、話は変わるかという質問があった。多層防御により一部の防御が機能する可能性があること、ゼロデイ脆弱性は非常に高価値で一般的な Web アプリへの攻撃には使われにくいことを説明した。

## 学んだこと

- 同一オリジンポリシーは**レスポンスの読み取り**をブロックし、リクエスト送信自体はブロックしない
- Origin ヘッダーはブラウザが自動設定する「禁止ヘッダー」であり、JavaScript から偽装不可
- ブラウザ脆弱性を想定しても、多層防御により一部の防御が機能する可能性がある
- ゼロデイ脆弱性は非常に高価値で、一般的な Web アプリへの攻撃には使われにくい

## 次のステップ

Issue #34（ユーザー認証）の全 Phase が完了。PR をマージして Issue をクローズする。
