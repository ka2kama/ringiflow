# 2026-01-15_07: テナント退会時データ削除設計

## 概要

テナントが RingiFlow を退会する際の、個人情報を含むデータの削除方針と実装設計を策定した。Event Sourcing の不変性原則と GDPR/個人情報削除要件の衝突を検討し、「テナント単位での完全物理削除」を採用方針として決定した。

## 背景と目的

RingiFlow はエンタープライズ向け SaaS であり、テナント退会時に個人情報を適切に削除する必要がある。しかし、以下の課題があった。

1. **データストアの多様性**: PostgreSQL、DynamoDB、S3、Redis など複数のデータストアに跨るデータを漏れなく削除する必要がある
2. **Event Sourcing との衝突**: イベントの不変性原則と個人情報削除要件は本質的に矛盾する
3. **契約と技術の乖離リスク**: 契約上は「匿名化で可」としていても、後から「物理削除を」と要求されるケースへの対応

## 実施内容

### 1. 現状のデータ構造調査

既存の設計書・要件定義書を調査し、削除対象となるデータを洗い出した。

- PostgreSQL: tenants, users, roles, workflow_* 系テーブル
- DynamoDB: audit_logs, workflow_events, notifications, feature_flags
- S3: documents, exports, logs
- Redis: session, csrf, stats

### 2. 削除方針の検討

以下の選択肢を比較検討した。

| 方式 | 完全削除 | Event不変性 | 実装容易性 |
|------|---------|------------|-----------|
| Crypto Shredding | △ | ✅ | ○ |
| テナント単位物理削除 | ✅ | △ | ✅ |
| 匿名化（上書き） | △ | △ | ✅ |
| 個人情報分離保存 | ✅ | ✅ | ✗ |

### 3. 設計原則の決定

「技術的には完全削除できる状態を作り、運用で制御する」を原則とした。

- 契約や原則が「匿名化」であっても、技術的に「完全削除」が可能な設計にしておく
- 顧客要求や法規制の変化に対応できる柔軟性を確保

### 4. 漏れ防止の仕組み設計（多層防御）

「人の注意力」に頼らず、システム的に漏れを防ぐ多層防御を設計した。

| Layer | チェック内容 | タイミング |
|-------|------------|-----------|
| 型システム | tenant_id 必須の構造 | コンパイル時 |
| 削除レジストリ | 登録されたものだけ削除 | 実行時 |
| 統合テスト | 削除後 0 件検証 | CI |
| CI チェック | 新規追加時の削除処理確認 | PR |
| Claude Code ルール | AI が自動でチェック項目を確認 | 開発時 |
| 本番監査バッチ | 削除済みテナントの残存確認 | 定期実行 |

## 成果物

### 作成したファイル

| ファイル | 説明 |
|---------|------|
| `docs/04_ADR/007_テナント退会時のデータ削除方針.md` | 意思決定記録 |
| `docs/02_設計書/07_テナント退会時データ削除設計.md` | 実装設計書 |
| `.claude/rules/data-store.md` | Claude Code 用ルール（データストア追加時に自動適用） |

### 更新したファイル

| ファイル | 変更内容 |
|---------|---------|
| `CLAUDE.md` | データストア追加時の必須チェック項目を追記 |

## 設計判断と実装解説

### Event Sourcing と完全削除の両立

Event Sourcing では「イベントは不変」が原則だが、この原則と「完全削除」は本質的に衝突する。

検討した対処パターン:

1. **Crypto Shredding**: イベント内の個人情報を暗号化し、削除時は鍵を削除
   - 問題: 「復号できない状態」を「削除した」と言えるか疑問

2. **テナント単位物理削除**: 退会テナントのイベントを物理的に削除
   - 採用理由: 退会テナントのデータを再構築する必要がないため、不変性を破っても実害なし

### 監査ログの扱い

監査ログは契約/テナントポリシーによって処理を分岐する設計とした。

- `delete`: 物理削除（GDPR 対応）
- `anonymize`: actorId→ハッシュ、sourceIp→マスク
- `retain`: 保持（法的要件がある場合）

契約時にポリシーを決定し、退会時に「やはり全部消してくれ」とごねられた場合への対策として:

- ポリシーは契約時にロックし、後からの変更は「プランアップグレード + 追加費用」とする
- 技術的には完全削除可能なので、例外対応は可能だがエスカレーション必須

### キー設計の統一

すべてのデータストアで `tenant_id` による効率的な削除を可能にする設計を必須とした。

```
PostgreSQL: 外部キーに CASCADE / SET NULL 完備
DynamoDB:   PK = tenant_id（または GSI で tenant_id 検索可能に）
S3:         パス = {tenant_id}/...
Redis:      キー = {type}:{tenant_id}:{id}
```

この設計により、後から「削除機能を追加して」と言われても対応可能になる。

## ユーザープロンプト（抜粋）

> テナントが退会したとき、個人情報の始末はどうしますか？

> 不具合も漏れもなく削除できるかを詰めたいです。

> よくあるのが、マスクでいくと決めているのに顧客がごねて物理削除させようとするときです。

> 技術的には、最初から削除を念頭に作り込んでおくと後で泣きを見なさそうです。仮に契約や原則がマスクだったとしても。

> 復号できない状態を「削除した」と言えますか？

> すべてのデータストアで tenant_id による削除が可能な設計が必須となる、新規データストア追加時に削除処理の実装を忘れると漏れが発生するリスク、別テナントのイベントを削除しても影響ない作り、このあたりを漏れずにチェックできる機構が欲しいです。

> Claude Code にもチェックさせたいです。

> この分野にあまり詳しくないが、これくらいやれば十分と言えますか？

> その観点もどこかに書いておいてください。

## 学んだこと

1. **技術的純粋さよりビジネス要件を優先**: Event Sourcing の不変性は重要だが、「退会して二度と使わないデータ」に対してまでこの原則を守る実益がない

2. **後付けで苦しまない設計**: 契約上は「匿名化で可」でも、技術的には「完全削除できる」状態を作っておくことで、将来の要件変化に対応できる

3. **「削除」の定義の曖昧さ**: Crypto Shredding を「削除」とみなせるかは法域・顧客によって異なる。エンタープライズ向けでは「物理的に消した」と言えることが重要

4. **多層防御の重要性**: 人の注意力に頼るチェックリストだけでは不十分。型システム、テスト、CI、AI ルールなど複数のレイヤーで漏れを防ぐ仕組みが必要

## 次のステップ

1. DB マイグレーションで外部キー制約を CASCADE/SET NULL に修正
2. DynamoDB テーブル設計で tenant_id をキーに含める修正
3. `TenantDeleter` トレイトと `DeletionRegistry` の実装
4. 削除バッチの実装
5. 検証バッチの実装
6. 統合テスト（`test_tenant_deletion_removes_all_data`, `test_all_data_stores_are_registered`）の追加
7. CI ワークフロー（`data-store-check.yml`）の追加
