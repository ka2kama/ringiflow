# ADR-006: コマンドランナーの選定

## ステータス

承認済み（2026-01-14）

## コンテキスト

RingiFlow はモノレポ構成で、Rust（バックエンド）と Elm（フロントエンド）を含む。開発において以下のような繰り返しタスクが発生する:

- 依存サービスの起動（Docker Compose）
- 開発サーバーの起動
- フォーマット・リント・テストの実行
- 初回セットアップの自動化
- CI での一括チェック

これらのタスクを統一的に管理・実行するコマンドランナーが必要。

### 要件

1. シンプルな構文: 学習コストが低く、可読性が高い
2. クロスプラットフォーム: Linux, macOS, Windows で動作
3. ドキュメント性: 利用可能なタスク一覧を容易に確認できる
4. 依存の少なさ: 追加の言語ランタイムを必要としない
5. エラーハンドリング: 失敗時の挙動が明確

## 検討した選択肢

### 選択肢 1: Make

UNIX 系 OS に標準搭載されるビルド自動化ツール。

評価:
- 利点: 追加インストール不要（Linux/macOS）、広く普及、依存関係の記述が可能
- 欠点: 構文が古く直感的でない、Windows では別途インストールが必要、タブ vs スペース問題、変数展開の複雑さ

### 選択肢 2: npm scripts / pnpm scripts

package.json の scripts セクションでタスクを定義。

評価:
- 利点: Node.js プロジェクトでは追加ツール不要、フロントエンド開発者に馴染み深い
- 欠点: Rust プロジェクトには不自然、複雑なスクリプトは可読性が低下、モノレポ全体の統一管理が困難

### 選択肢 3: Task (go-task)

Go 製のタスクランナー。YAML でタスクを定義。

評価:
- 利点: YAML による構造化された定義、クロスプラットフォーム、依存関係の記述が可能
- 欠点: YAML の冗長性、インデントに敏感、シェルコマンドの記述がやや煩雑

### 選択肢 4: just

Rust 製のコマンドランナー。Make に似た構文だが、より現代的で直感的。

評価:
- 利点: シンプルで読みやすい構文、クロスプラットフォーム、`--list` でタスク一覧表示、引数・変数サポート、.env 読み込み対応
- 欠点: 追加インストールが必要、Make ほどの普及度はない

### 選択肢 5: cargo-make

Rust 製のビルド自動化ツール。TOML（Makefile.toml）でタスクを定義し、cargo のサブコマンドとして動作。

評価:
- 利点: cargo エコシステムに統合、TOML で設定（Rust プロジェクトに馴染む）、豊富なビルトインタスク、条件分岐・依存関係の記述が充実、CI 向け機能が豊富
- 欠点: TOML 設定が冗長になりがち、シンプルなタスクには過剰、学習コストがやや高い、Elm 側のタスクには cargo 統合のメリットが薄い

### 比較表

| 観点 | Make | npm scripts | Task | just | cargo-make |
|------|------|-------------|------|------|------------|
| 構文のシンプルさ | △ | △ | ○ | ◎ | ○ |
| クロスプラットフォーム | △ | ○ | ◎ | ◎ | ◎ |
| 追加インストール | 不要（Linux/macOS） | 不要 | 必要 | 必要 | 必要 |
| タスク一覧表示 | △ | △ | ◎ | ◎ | ◎ |
| モノレポ対応 | ○ | △ | ◎ | ◎ | ○ |
| 可読性 | △ | △ | ○ | ◎ | ○ |
| Rust との親和性 | ○ | × | ○ | ◎ | ◎ |
| 非 Rust タスクとの統一感 | ○ | ◎ | ◎ | ◎ | △ |

## 決定

**選択肢 4: just** を採用する。

理由:

1. 構文のシンプルさと可読性: Make のタブ問題や複雑な変数展開がなく、直感的に読み書きできる
2. 自己文書化: `just --list` でコメント付きのタスク一覧を表示でき、「暗黙知ゼロ」の理念と合致
3. Rust エコシステムとの親和性: Rust 製ツールであり、プロジェクトの技術スタックと統一感がある
4. mise との統合: mise で just をインストール・バージョン管理でき、開発環境の一貫性を保てる

### Make を選ばなかった理由

Make は広く普及しているが、以下の点で現代的なワークフローに適さない:

- タブ vs スペースの問題が初学者の混乱を招く
- 変数展開（`$(VAR)` vs `${VAR}` vs `$$VAR`）が複雑
- Windows 環境でのセットアップが煩雑
- タスク一覧の表示に追加の工夫が必要

### npm scripts を選ばなかった理由

フロントエンド単体なら自然だが、モノレポ全体を管理するには不適:

- Rust プロジェクトのタスクを package.json で管理するのは不自然
- 複雑なスクリプトは一行に詰め込む必要があり可読性が低下
- ルートとサブパッケージ間のスクリプト連携が煩雑

### cargo-make を選ばなかった理由

Rust プロジェクト単体なら有力候補だが、本プロジェクトの要件には合わない:

- モノレポで Elm（フロントエンド）も管理するため、「cargo のサブコマンド」という位置づけが不自然
- TOML 設定が冗長で、シンプルなタスク（`pnpm run dev` の実行など）には過剰
- just の方が構文がシンプルで学習コストが低い
- 「暗黙知ゼロ」の観点で、justfile の方が一目で内容を把握しやすい

cargo-make は Rust 純粋プロジェクトや、複雑なビルドパイプライン（条件分岐、プラットフォーム別処理など）が必要な場合には優れた選択肢。

## 帰結

### 肯定的な影響

- 開発タスクが `just <タスク名>` で統一的に実行可能
- `just --list` で利用可能なタスクを即座に確認可能
- justfile がプロジェクトのタスク仕様書として機能
- 新規参画者がすぐに開発を開始できる

### 否定的な影響・トレードオフ

- just のインストールが必要（mise で管理）
- Make ほど普及していないため、初見では学習が必要（ただし構文は直感的）
- CI 環境でも just のインストールが必要

### 関連ドキュメント

- 手順書: [`docs/60_手順書/01_開発参画/01_開発環境構築.md`](../60_手順書/01_開発参画/01_開発環境構築.md)
- 実装: [`justfile`](../../justfile)

---

## 変更履歴

| 日付 | 変更内容 |
|------|---------|
| 2026-01-14 | 初版作成 |
