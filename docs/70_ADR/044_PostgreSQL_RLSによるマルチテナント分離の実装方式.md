# ADR-044: PostgreSQL RLS によるマルチテナント分離の実装方式

## ステータス

承認済み

## コンテキスト

RingiFlow は Phase 1 でアプリケーション層（リポジトリの `WHERE tenant_id = $1`）によるテナント分離のみ実装していた。基本設計書 7.1.3 節で定義された二重防御（アプリケーション層 + DB 層）の DB 層が未実装であり、Phase 2-1 で PostgreSQL RLS（Row Level Security）を導入する必要があった。

背景:
- 全 9 テナントスコープテーブルに対する一貫した DB レベルの分離が必要
- 既存リポジトリの `&self.pool` パターンを維持しつつ RLS を導入したい
- `#[sqlx::test]` は superuser で接続するため、RLS のテスト方法を検討する必要がある

関連する制約条件:
- マルチテナント要件（CORE-03, AUTHZ-003）
- テナント退会時の完全削除要件（ADR-007）
- Pool モデル（共有 DB + 共有スキーマ）での運用

## 検討した選択肢

### 判断 1: コネクション管理方式

#### 選択肢 A: after_release フック + TenantConnection

プールのコネクション返却時に `set_config('app.tenant_id', '', false)` を実行してテナントコンテキストをリセット。`TenantConnection` 型でテナント ID 設定済みのコネクションを取得する。

評価:
- 利点: 既存リポジトリの `&self.pool` パターンを変更不要。コネクション返却時の自動リセットでリーク防止
- 欠点: コネクション返却ごとに `set_config` が実行される（軽微なパフォーマンスコスト）

#### 選択肢 B: リクエストスコープトランザクション

全リクエストを `BEGIN` + `SET LOCAL` + `COMMIT` で包む。

評価:
- 利点: `SET LOCAL` はトランザクションスコープで自動リセットされる
- 欠点: 全リポジトリの Executor 型を `Transaction` に変更する必要がある。既存コードへの影響が大きい

#### 選択肢 C: axum ミドルウェアで Connection を渡す

axum の Extension でテナントコンテキスト設定済みコネクションを共有。

評価:
- 利点: フレームワークレベルでの統一的な管理
- 欠点: Core Service は内部 API として動作するため、axum Extension への依存がアーキテクチャ上不適切

#### 比較表

| 観点 | A: after_release | B: リクエストスコープ Tx | C: axum Extension |
|------|-----------------|------------------------|-------------------|
| 既存コードへの影響 | ◎ 最小 | ✕ 全リポジトリ変更 | △ Core Service に不適 |
| リーク防止 | ◎ 自動リセット | ◎ トランザクションスコープ | △ 手動管理 |
| パフォーマンス | ○ 返却ごとに 1 クエリ | ○ リクエストごとに BEGIN/COMMIT | ○ 同等 |
| アーキテクチャ適合 | ◎ レイヤー非依存 | ○ 適合 | ✕ axum 依存 |

### 判断 2: tenant_id カラムがないテーブルの対応

`workflow_steps` と `user_roles` は `tenant_id` カラムを持たず、親テーブル経由でテナントを特定していた。

#### 選択肢 A: tenant_id カラムを追加（非正規化）

各テーブルに直接 `tenant_id` カラムを追加し、既存データをバックフィル。

評価:
- 利点: RLS ポリシーが単純。JOIN 不要でパフォーマンス良好。他テーブルと一貫したパターン
- 欠点: 非正規化によるデータ冗長性。INSERT 時に tenant_id の整合性を維持する必要がある

#### 選択肢 B: JOIN ベースの RLS ポリシー

RLS ポリシー内で親テーブルと JOIN して tenant_id を参照。

評価:
- 利点: 正規化を維持
- 欠点: PostgreSQL 公式ドキュメントで非推奨。全行に対して JOIN が評価されパフォーマンス劣化

#### 比較表

| 観点 | A: カラム追加 | B: JOIN ベース |
|------|-------------|---------------|
| RLS ポリシーの単純さ | ◎ 単一カラム比較 | ✕ JOIN + サブクエリ |
| パフォーマンス | ◎ インデックス利用可能 | ✕ 全行 JOIN |
| 公式推奨 | ◎ 推奨パターン | ✕ 非推奨 |
| データ整合性 | △ 非正規化 | ◎ 正規化維持 |

## 決定

### 判断 1: 選択肢 A（after_release フック + TenantConnection）を採用

主な理由:
1. 既存リポジトリの `&self.pool` パターンを維持でき、既存コードへの影響が最小
2. `after_release` フックでコネクション返却時に自動リセットされるため、テナントコンテキストのリーク防止が構造的に保証される
3. `TenantConnection` 型は将来のリポジトリ統合の基盤として機能する

### 判断 2: 選択肢 A（tenant_id カラム追加）を採用

主な理由:
1. PostgreSQL 公式ドキュメントで JOIN ベースの RLS ポリシーは非推奨
2. 全テーブルで一貫したパターンを適用でき、保守性が高い

### RLS ポリシーの SQL パターン

```sql
-- テナントコンテキスト設定（set_config を使用。SET はパラメータ化クエリ非対応）
SELECT set_config('app.tenant_id', $1, false);

-- テナントコンテキストリセット（コネクション返却時）
SELECT set_config('app.tenant_id', '', false);

-- RLS ポリシー（未設定時はどの行もマッチしない安全設計）
CREATE POLICY tenant_isolation ON テーブル名
    USING (tenant_id = NULLIF(current_setting('app.tenant_id', true), '')::UUID);
```

`current_setting('app.tenant_id', true)` の第 2 引数 `true` は missing_ok。未設定時にエラーではなく空文字列を返す。`NULLIF` で空文字列を `NULL` に変換し、`tenant_id = NULL` が常に `false` となることで、未設定時はどの行もマッチしない安全設計。

## 帰結

### 肯定的な影響

- 全 9 テナントスコープテーブルに一貫した RLS ポリシーが適用され、DB レベルでのテナント分離が確立された
- アプリケーション層の WHERE 句（主防御線）+ RLS（セーフティネット）の二重防御が完成した
- `app.tenant_id` 未設定時はどの行もマッチしないため、設定漏れ時の安全性が保証される
- 既存リポジトリのコードへの影響が最小限に抑えられた

### 否定的な影響・トレードオフ

- `workflow_steps` と `user_roles` に `tenant_id` カラムを非正規化で追加。INSERT 時の整合性維持が必要
- コネクション返却ごとに `set_config` が実行される軽微なパフォーマンスコスト
- `#[sqlx::test]` は superuser で接続するため BYPASSRLS が有効。RLS のテストには `SET ROLE` で非 superuser に切り替える必要がある

### 関連ドキュメント

- 設計書: [03_インフラとDB設計.md 7.1.3 節](../30_基本設計書/03_インフラとDB設計.md)
- ADR: [ADR-007 テナント退会時のデータ削除方針](007_テナント退会時のデータ削除方針.md)
- ADR: [ADR-023 バックエンドアーキテクチャパターンの選択](023_バックエンドアーキテクチャパターンの選択.md)
- 実装計画: `prompts/plans/402_multi-tenant-rls.md`
- Epic: #402（Phase 2-1: マルチテナント RLS 実装）

---

## 変更履歴

| 日付 | 変更内容 |
|------|---------|
| 2026-02-11 | 初版作成 |
