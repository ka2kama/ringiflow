# ADR-058: プロパティベーステスト（proptest）の導入

## ステータス

承認済み（2026-02-27）

## コンテキスト

現在のテストは rstest によるパラメータ化テストと手書きのテストケースで構成されている。状態遷移の個別テストは充実しているが、「任意の操作列の後で不変条件が保持されるか」という性質ベースの検証は行っていない。

Issue #939 のテスト戦略拡充に伴い、以下の課題が明らかになった:

- 手動列挙によるテストケースでは操作列の組み合わせ空間をカバーしきれない
- 既存の `assert_workflow_invariants()` 関数は不変条件チェックの基盤として機能しているが、ランダムな操作列と組み合わせる仕組みがない
- 実装ガイドライン（`docs/40_詳細設計書/05_実装ガイドライン.md`）に「プロパティテスト: 不変条件: proptest」と記載済みだが、正式な導入判断がされていない

## 検討した選択肢

### 選択肢 1: proptest を導入する

Rust の代表的なプロパティベーステストフレームワーク。Haskell の QuickCheck にインスパイアされた設計。ランダム入力を生成し、プロパティ（性質）が成り立つことを検証する。

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_任意の操作列で不変条件が保持される(
        ops in prop::collection::vec(arb_operation(), 1..20)
    ) {
        let mut instance = create_draft_instance();
        for op in ops {
            // 操作を適用（エラーは無視して次の操作へ）
            let _ = apply_operation(instance.clone(), op);
        }
        assert_workflow_invariants(&instance);
    }
}
```

評価:
- 利点: 人間が思いつかない操作列を自動生成、シュリンキング（失敗ケースの最小化）、再現可能なシード値
- 欠点: テスト実行時間が増加（デフォルト 256 ケース）、Arbitrary 実装の初期コスト

### 選択肢 2: rstest のパラメータ化テストで代替する

既に利用中の rstest を使い、手動で列挙した操作列パターンをパラメータ化テストとして記述する。

```rust
#[rstest]
#[case(vec![Op::Submit, Op::SetStep, Op::Approve])]
#[case(vec![Op::Submit, Op::SetStep, Op::Reject])]
#[case(vec![Op::Submit, Op::SetStep, Op::RequestChanges, Op::Resubmit, Op::Approve])]
fn test_操作列で不変条件が保持される(#[case] ops: Vec<Op>) {
    // ...
}
```

評価:
- 利点: 追加依存なし、テスト実行時間が予測可能、テストケースが明示的
- 欠点: 手動列挙のため網羅性に限界、新しい操作追加時にテストケースの追加漏れが発生しやすい

### 選択肢 3: 見送る

現状の個別テスト + `assert_workflow_invariants()` を維持し、プロパティベーステストは導入しない。

評価:
- 利点: 追加コストゼロ、テストの複雑さが増えない
- 欠点: 操作列の組み合わせ空間が未探索のまま、不変条件の検証が特定のシナリオに限定される

### 比較表

| 観点 | proptest | rstest 代替 | 見送り |
|------|---------|------------|--------|
| 操作列の探索力 | 高（ランダム生成） | 低（手動列挙） | なし |
| 不変条件の検証力 | 高（任意の操作列） | 中（列挙済みの操作列） | 低（個別シナリオ） |
| 導入コスト | 中（依存追加 + Arbitrary 実装） | 低（既存ツール） | なし |
| メンテナンスコスト | 低（操作追加 → Arbitrary に追加） | 中（操作追加 → ケース追加漏れリスク） | 低 |
| テスト実行時間 | やや増加（256 ケース） | 変わらない | 変わらない |
| 学習効果 | 高（プロパティベーステストのパラダイム） | 低（既知の手法） | なし |
| 既存基盤との統合 | 高（`assert_workflow_invariants()` をそのまま活用） | 同左 | — |
| エコシステム成熟度 | 高（v1.10.0、DL 9750 万回超） | — | — |

## 決定

**選択肢 1: proptest を導入する。**

主な理由:

1. 既存の `assert_workflow_invariants()` と自然に統合でき、ランダムな操作列で不変条件の保持を検証できる
2. 手動列挙では漏れる操作列の組み合わせ空間を確率的に探索できる（選択肢 2 の限界を補完）
3. プロパティベーステストは品質追求とテスト設計の学習効果が高い（プロジェクト理念との整合）

選択肢 2 は proptest の補完として併用する（重要な操作列は rstest で明示的に、組み合わせ空間は proptest で探索的に検証）。

## 帰結

### 肯定的な影響

- 操作列の組み合わせ空間を確率的に探索できるようになる
- 不変条件の検証が特定シナリオから「任意の操作列」に拡張される
- シュリンキングにより、失敗ケースの最小再現が自動で得られる
- テスト設計の新しいパラダイム（性質ベース）が導入され、学習効果が高い

### 否定的な影響・トレードオフ

- workspace の dev-dependencies に proptest が追加される
- Arbitrary トレイトの実装に初期コストがかかる
- テスト実行時間がやや増加する（`PROPTEST_CASES` で調整可能）
- 非決定的なテスト失敗が発生する可能性がある（シード値で再現可能）

### 適用範囲

ドメイン層の不変条件テストを主な適用対象とする。以下の順序で段階的に導入する:

1. WorkflowInstance: 状態遷移の不変条件（INV-I1〜I9、INV-X1〜X3）
2. WorkflowStep: 状態遷移の不変条件（INV-S1〜S4）
3. 値オブジェクト: 境界値のプロパティ（例: `parse(display(x)) == x` の往復テスト）

### 今後の作業

- [ ] `backend/Cargo.toml` の workspace dev-dependencies に `proptest = "1.10"` を追加
- [ ] ドメイン層に `Arbitrary` 実装を追加（`WorkflowInstanceState`, `WorkflowStepState`, 操作の enum）
- [ ] 不変条件のプロパティテストを追加
- [ ] CI でのテスト実行時間を監視し、必要に応じて `PROPTEST_CASES` を調整

### 関連ドキュメント

- 設計書: [テスト戦略: エッジケース方針](../50_テスト/テスト戦略_エッジケース方針.md)
- 設計書: [状態遷移表（WorkflowInstance）](../50_テスト/状態遷移表_WorkflowInstance.md)
- 設計書: [状態遷移表（WorkflowStep）](../50_テスト/状態遷移表_WorkflowStep.md)
- 関連 ADR: [ADR-032: テスト設計方針](032_テスト設計方針.md)
- 関連 ADR: [ADR-054: 型安全ステートマシンパターンの標準化](054_型安全ステートマシンパターンの標準化.md)
- 不変条件定義: [エンティティ影響マップ](../40_詳細設計書/エンティティ影響マップ/)

---

## 変更履歴

| 日付 | 変更内容 |
|------|---------|
| 2026-02-27 | 初版作成（#939） |
