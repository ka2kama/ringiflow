# ADR-001: ID 形式の選定

## ステータス

承認済み（2026-01-13）

## コンテキスト

RingiFlow では、様々なエンティティ（テナント、ユーザー、ワークフロー、タスク、イベント等）を一意に識別する ID が必要である。

ID 形式の選定にあたり、以下の要件を考慮する必要がある:

1. 型安全性: Rust の型システムを活用し、ID の取り違えをコンパイル時に検出したい
2. 時系列ソート: Event Sourcing を採用するため、イベント ID は生成順でソート可能であることが望ましい
3. 分散生成: 複数のサービスインスタンスから調整なしで ID を生成できること
4. 標準準拠: 業界標準に従い、エコシステムのサポートを受けたい
5. DB 互換性: PostgreSQL の UUID 型にネイティブで格納できること

また、プロジェクト方針「暗黙知ゼロ」に基づき、選定理由を明確に文書化する。

## 検討した選択肢

### 選択肢 1: UUID v4（ランダム）のみ

すべての ID に UUID v4 を使用する。

```
UUID v4 構造 (128bit):
┌────────────────────────────────────────────────────────┐
│ Random (122bit) + Version (4bit) + Variant (2bit)      │
└────────────────────────────────────────────────────────┘
```

評価:
- 利点: シンプル、広くサポート、衝突確率が極めて低い
- 欠点: 時系列ソート不可、インデックス効率が悪い（ランダム挿入）

### 選択肢 2: UUID v4 + UUID v7（用途別）

参照系には UUID v4、時系列系には UUID v7 を使い分ける。

```
UUID v7 構造 (128bit):
┌───────────────────┬────┬──┬─────────────────────────────┐
│ Timestamp (48bit) │ Ver│Va│ Random (74bit)              │
│ ミリ秒精度         │ 4b │2b│                             │
└───────────────────┴────┴──┴─────────────────────────────┘
```

評価:
- 利点: RFC 9562 標準、時系列ソート可能、単一ライブラリ
- 欠点: v4 と v7 が同じ型（Uuid）なので型レベルでの区別が必要

### 選択肢 3: ULID + UUID

参照系には UUID v4、時系列系には ULID を使用する。

```
ULID 構造 (128bit):
┌───────────────────┬──────────────────────────┐
│ Timestamp (48bit) │ Randomness (80bit)       │
└───────────────────┴──────────────────────────┘
文字列: 01ARZ3NDEKTSV4RRFFQ69G5FAV (26文字)
```

評価:
- 利点: 異なる型による自然な区別、より多いランダムビット（80 vs 74）
- 欠点: RFC 標準外、2つの ID システム管理、エコシステム分断

### 選択肢 4: Snowflake ID

Twitter が開発した 64bit の時系列 ID。

```
Snowflake 構造 (64bit):
┌─────────────────┬──────────┬──────────────┐
│ Timestamp (41b) │ Node (10)│ Sequence (12)│
└─────────────────┴──────────┴──────────────┘
```

評価:
- 利点: コンパクト（64bit）、高スループット（秒間数百万 ID）
- 欠点: マシン ID 管理が必要、PostgreSQL UUID 型と非互換、標準外

### 選択肢 5: KSUID

Segment 社が開発した 160bit の ID。

```
KSUID 構造 (160bit):
┌───────────────────┬──────────────────────────────┐
│ Timestamp (32bit) │ Randomness (128bit)          │
└───────────────────┴──────────────────────────────┘
```

評価:
- 利点: 大きなランダム部、秒精度タイムスタンプ
- 欠点: 160bit は PostgreSQL UUID 型に格納不可、Segment 独自仕様

### 選択肢 6: Auto-increment

データベースの連番 ID（SERIAL, BIGSERIAL）を主キーとして単独使用。

評価:
- 利点: シンプル、省スペース
- 欠点: 予測可能（セキュリティリスク）、分散生成不可、DB 依存

### 選択肢 7: BIGSERIAL + UUID（内部/外部分離）

内部キーに BIGSERIAL、外部公開用に別カラムで UUID を持つハイブリッドパターン。

```sql
CREATE TABLE entities (
    id BIGSERIAL PRIMARY KEY,           -- 内部用（FK、JOIN）
    public_id UUID NOT NULL UNIQUE,     -- 外部公開用（API、URL）
    ...
);
```

評価:
- 利点: B-tree 効率が最高（シーケンシャル挿入）、JOIN が高速（8 bytes）、外部 ID は推測困難
- 欠点: 2つの ID 体系の管理、クエリの複雑化（外部→内部変換）、FK の扱いが曖昧、分散システムで auto increment が制約に

### 比較表

| 観点 | UUID v4 | UUID v4+v7 | ULID+UUID | Snowflake | KSUID | Auto-inc | BIGSERIAL+UUID |
|------|---------|-----------|-----------|-----------|-------|----------|----------------|
| 標準化 | RFC | RFC | △ | × | × | - | - |
| 時系列ソート | × | ○ | ○ | ○ | ○ | ○ | ○ |
| 分散生成 | ○ | ○ | ○ | △ | ○ | × | △ |
| 調整不要 | ○ | ○ | ○ | × | ○ | × | × |
| PostgreSQL UUID 型 | ○ | ○ | ○ | × | × | - | ○ |
| 単一システム | ○ | ○ | × | ○ | ○ | ○ | × |
| 型安全性 | △ | △ | ○ | △ | △ | △ | △ |
| B-tree 効率 | × | ○ | ○ | ○ | ○ | ○ | ○ |
| 設計のシンプルさ | ○ | ○ | △ | ○ | ○ | ○ | × |

※ 型安全性はいずれも Newtype パターンで向上可能

## 決定

選択肢 2: UUID v4 + UUID v7（用途別）を採用する。

### 採用理由

1. RFC 9562 標準: UUID v7 は 2024年5月に RFC 標準化された。ULID の機能を標準仕様として提供しており、長期的なエコシステムサポートが期待できる。

2. 単一ライブラリ: Rust の `uuid` crate で v4 と v7 の両方を生成できる。2つの ID ライブラリを管理する複雑性を回避。

3. PostgreSQL 互換: UUID 型にネイティブ格納可能。KSUID（160bit）や Snowflake（64bit BIGINT）と異なり、型変換が不要。

4. 型安全性は Newtype で解決: v4 と v7 が同じ `Uuid` 型である問題は、Newtype パターン（`TenantId(Uuid)`, `EventId(Uuid)`）で解決可能。これは ULID を使っても必要な作業であり、追加コストではない。

### 却下理由

- ULID + UUID: 型レベルの区別は魅力的だが、UUID v7 標準化により ULID の優位性が薄れた。2システム管理のコストに見合わない。
- Snowflake: マシン ID の調整が必要。RingiFlow の規模では過剰なスループットは不要。
- KSUID: 160bit は PostgreSQL UUID 型に収まらない。
- Auto-increment: セキュリティリスク、分散生成不可。
- BIGSERIAL + UUID: B-tree 効率は魅力的だが、以下の理由で不採用。
  1. **UUID v7 で B-tree 効率問題はほぼ解決** - 追加の複雑さに見合わない
  2. **Event Sourcing では分散 ID 生成が必須** - イベント ID は DB 非依存で生成する必要があり、結局 UUID が必要
  3. **2つの ID 体系は認知負荷を増やす** - FK は内部 ID？外部 ID？という曖昧さが生まれる
  4. **想定規模では UUID のオーバーヘッドは許容範囲** - 3年後 500 テナント、10万ユーザー規模で問題になる差ではない

## 帰結

### 肯定的な影響

- RFC 標準に準拠し、業界のベストプラクティスに沿った設計
- 単一の `uuid` crate で完結し、依存関係がシンプル
- PostgreSQL UUID 型との完全な互換性
- 時系列系 ID（イベント、タスク等）は生成順でソート可能

### 否定的な影響・トレードオフ

- UUID v7 のタイムスタンプから作成時刻が推測可能（許容する）
- Newtype パターンの実装が必要（マクロで軽減）
- v4 と v7 の使い分けルールを開発者が理解する必要がある

### 関連ドキュメント

- 設計書: [04_ID設計規約.md](../40_詳細設計書/04_ID設計規約.md) - 実装方法の詳細
- 実装: `packages/domain/src/id/` - ID 型の実装（Phase 0 以降）

---

## 変更履歴

| 日付 | 変更内容 |
|------|---------|
| 2026-01-13 | 初版作成 |
| 2026-01-17 | 選択肢 7（BIGSERIAL + UUID）を追加、却下理由を明記 |
