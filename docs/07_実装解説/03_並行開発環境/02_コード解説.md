# 並行開発環境 - コード解説

対応 PR: #96

## 主要な型・関数

| 型/関数 | ファイル | 責務 |
|--------|---------|------|
| `generate-env.sh` | [`scripts/generate-env.sh`](../../../scripts/generate-env.sh) | ポートオフセット付き `.env` ファイル生成 |
| `worktree-add` | [`justfile`](../../../justfile) | worktree 作成 + オフセット自動割り当て + `.env` 生成 |
| `worktree-remove` | [`justfile`](../../../justfile) | Docker コンテナ停止・削除 + worktree 削除 |
| `worktree-list` | [`justfile`](../../../justfile) | worktree 一覧 + Docker プロジェクト一覧 |
| `dev-deps` | [`justfile`](../../../justfile) | `basename $(pwd)` でプロジェクト名自動取得 → Docker Compose 起動 |
| `docker-compose.yaml` | [`infra/docker/docker-compose.yaml`](../../../infra/docker/docker-compose.yaml) | `container_name` 削除でプロジェクト名分離対応 |

## コードフロー

コードをライフサイクル順に追う。各ステップの構造を図で示した後、対応するコードを解説する。

```mermaid
flowchart LR
    A["1. オフセット収集<br/>（既存 worktree 探索）"] --> B["2. 空き番号探索<br/>（1-9 スキャン）"]
    B --> C["3. worktree 作成<br/>（git worktree add）"]
    C --> D["4. .env 生成<br/>（generate-env.sh）"]
    D --> E["5. Docker 起動<br/>（プロジェクト名分離）"]
    E --> F["6. 削除<br/>（Docker + worktree）"]
```

### 1. オフセット収集（使用中ポートの逆算）

既存 worktree の `.env` ファイルから `POSTGRES_PORT` を読み取り、使用中のオフセットを収集する。

```mermaid
flowchart TB
    List["git worktree list --porcelain"] --> Loop["各 worktree パスでループ"]
    Loop --> Read[".env から POSTGRES_PORT 読み取り"]
    Read --> Calc["オフセット = (port - 15432) / 100"]
    Calc --> Array["used_offsets 配列に追加"]
```

```bash
# justfile: worktree-add（オフセット収集部分）
used_offsets=()
while IFS= read -r wt_path; do
    env_file="$wt_path/.env"
    if [[ -f "$env_file" ]]; then
        port=$(grep -E '^POSTGRES_PORT=' "$env_file" 2>/dev/null | cut -d= -f2)  # ①
        if [[ -n "$port" ]]; then
            offset=$(( (port - 15432) / 100 ))     # ② ベースポートからの差分
            used_offsets+=("$offset")
        fi
    fi
done < <(git worktree list --porcelain | grep '^worktree ' | cut -d' ' -f2-)    # ③
```

注目ポイント:

- ① `.env` ファイルから `POSTGRES_PORT` の値を抽出
- ② ベースポート 15432 からの差分を 100 で割ってオフセットを逆算（例: 15532 → (15532-15432)/100 = 1）
- ③ `git worktree list --porcelain` でパスを取得。`--porcelain` は機械的に解析しやすい形式

### 2. 空き番号探索（1-9 スキャン）

使用中オフセットを避けて、1〜9 の範囲で空き番号を探す。

```mermaid
flowchart TB
    Start["i = 1"] --> Check{"i が used_offsets<br/>に含まれる？"}
    Check -->|Yes| Next["i++"]
    Next --> Check
    Check -->|No| Found["port_offset = i"]
    Found --> Done["空き番号確定"]
```

```bash
# justfile: worktree-add（空き番号探索部分）
port_offset=""
for i in {1..9}; do
    found=false
    if [[ ${#used_offsets[@]} -gt 0 ]]; then      # ① 空配列チェック
        for used in "${used_offsets[@]}"; do
            if [[ "$used" == "$i" ]]; then
                found=true
                break
            fi
        done
    fi
    if [[ "$found" == false ]]; then
        port_offset="$i"                            # ② 空きを発見
        break
    fi
done

if [[ -z "$port_offset" ]]; then
    echo "エラー: 空きポートオフセットがありません（最大9個まで）" >&2
    exit 1                                          # ③ 上限到達
fi
```

注目ポイント:

- ① `set -euo pipefail` 環境で空配列をイテレートするとエラーになるため、事前にサイズチェック
- ② 使用されていない最小のオフセットを選択
- ③ 1〜9 がすべて使用中の場合はエラー（最大 9 worktree の制約）

### 3. worktree 作成

ブランチの存在確認後、git worktree を追加する。

```bash
# justfile: worktree-add（worktree 作成部分）
if git rev-parse --verify "{{branch}}" >/dev/null 2>&1; then
    git worktree add "$WORKTREE_PATH" "{{branch}}"     # ① 既存ブランチ
else
    git worktree add -b "{{branch}}" "$WORKTREE_PATH"  # ② 新規ブランチ作成
fi
```

注目ポイント:

- ① ブランチが既に存在する場合はそのままチェックアウト
- ② 存在しない場合は `-b` で新規ブランチを作成しながら worktree を追加

### 4. `.env` 生成（generate-env.sh）

オフセット値を受け取り、ポート計算して `.env` を生成する。

```mermaid
flowchart TB
    Input["PORT_OFFSET（0-9）"] --> Calc["OFFSET = PORT_OFFSET × 100"]
    Calc --> Ports["POSTGRES: 15432 + OFFSET<br/>REDIS: 16379 + OFFSET<br/>BFF: 13000 + OFFSET<br/>..."]
    Ports --> Root[".env 生成<br/>（Docker Compose 用）"]
    Ports --> Backend["backend/.env 生成<br/>（Rust サービス用）"]
```

```bash
# scripts/generate-env.sh（抜粋）
PORT_OFFSET="${1:-0}"

# 基準ポート
BASE_POSTGRES_PORT=15432
BASE_REDIS_PORT=16379
BASE_BFF_PORT=13000
BASE_CORE_API_PORT=13001
BASE_VITE_PORT=15173

# オフセット計算（100 単位）
OFFSET=$((PORT_OFFSET * 100))                          # ①

POSTGRES_PORT=$((BASE_POSTGRES_PORT + OFFSET))          # ②

# ルート .env を生成
cat > "$PROJECT_ROOT/.env" << EOF
POSTGRES_PORT=$POSTGRES_PORT                             # ③
REDIS_PORT=$REDIS_PORT
BFF_PORT=$BFF_PORT
VITE_PORT=$VITE_PORT
EOF

# backend/.env を生成
cat > "$PROJECT_ROOT/backend/.env" << EOF
DATABASE_URL=postgres://ringiflow:ringiflow@localhost:$POSTGRES_PORT/ringiflow_dev  # ④
REDIS_URL=redis://localhost:$REDIS_PORT
CORE_API_PORT=$CORE_API_PORT
CORE_API_URL=http://localhost:$CORE_API_PORT
EOF
```

注目ポイント:

- ① 100 単位のオフセットで可読性と予測可能性を確保
- ② 各ベースポートにオフセットを加算
- ③ ルートの `.env` は Docker Compose が参照（`${POSTGRES_PORT}` 形式）
- ④ `backend/.env` は Rust サービスが `dotenv` で読み込み。`DATABASE_URL` にポートが反映

### 5. Docker 起動（プロジェクト名による分離）

`dev-deps` がディレクトリ名からプロジェクト名を自動取得し、Docker Compose を起動する。

```mermaid
flowchart LR
    PWD["basename $(pwd)<br/>→ ringiflow-auth"] --> Compose["docker compose<br/>-p ringiflow-auth"]
    Compose --> Container["ringiflow-auth-postgres-1<br/>:15532"]
    Compose --> Volume["ringiflow-auth_postgres_data"]
    Compose --> Network["ringiflow-auth_default"]
```

```bash
# justfile: dev-deps
dev-deps:
    #!/usr/bin/env bash
    PROJECT_NAME=$(basename "$(pwd)")                   # ① ディレクトリ名を取得
    docker compose -p "$PROJECT_NAME" -f infra/docker/docker-compose.yaml up -d --wait  # ②
```

注目ポイント:

- ① メイン worktree なら `ringiflow`、追加 worktree なら `ringiflow-auth` など
- ② `-p` でプロジェクト名を指定すると、コンテナ名・ボリューム名・ネットワーク名にプレフィックスが付く

### 6. 削除（Docker + worktree）

Docker コンテナを停止・削除してから、worktree を削除する。

```bash
# justfile: worktree-remove
worktree-remove name:
    #!/usr/bin/env bash
    set -euo pipefail
    PROJECT_NAME="ringiflow-{{name}}"

    # Docker コンテナを停止・削除
    containers=$(docker compose -p "$PROJECT_NAME" ... ps -q 2>/dev/null || true)  # ①
    if [[ -n "$containers" ]]; then
        docker compose -p "$PROJECT_NAME" ... down -v                               # ②
    fi

    # worktree を削除
    git worktree remove "$WORKTREE_PATH" --force                                    # ③
```

注目ポイント:

- ① `|| true` でコンテナが存在しない場合のエラーを吸収
- ② `-v` でボリュームも含めて完全削除
- ③ `--force` で未コミットの変更があっても削除可能

## 設計解説

コード実装レベルの判断を記載する。機能・仕組みレベルの判断は[機能解説](./01_機能解説.md#設計判断)を参照。

### 1. `set -euo pipefail` 環境での空配列チェック

場所: `justfile` の `worktree-add` タスク

```bash
if [[ ${#used_offsets[@]} -gt 0 ]]; then
    for used in "${used_offsets[@]}"; do
        ...
    done
fi
```

なぜこの実装か:

Bash の `set -u`（未定義変数エラー）が有効な場合、空配列のイテレーション `"${array[@]}"` がエラーになる。配列サイズを事前チェックすることで安全に動作する。

代替案:

| 案 | メリット | デメリット | 判断 |
|----|---------|-----------|------|
| 空配列チェック（採用） | 安全、明示的 | コードが冗長 | 採用 |
| `${array[@]+"${array[@]}"}` | 1 行で完結 | 可読性が低い | 見送り |
| `set +u` で一時的に無効化 | シンプル | 安全性が低下 | 見送り |

### 2. `|| true` によるエラー吸収

場所: `justfile` の `worktree-remove` タスク

```bash
containers=$(docker compose ... ps -q 2>/dev/null || true)
if [[ -n "$containers" ]]; then
```

なぜこの実装か:

`set -euo pipefail` 環境で `docker compose ps -q` がコンテナ未起動時にエラーを返すと、スクリプト全体が停止する。`|| true` でエラーを吸収し、変数が空かどうかで判定することで堅牢に動作する。

代替案:

| 案 | メリット | デメリット | 判断 |
|----|---------|-----------|------|
| `|| true` + 変数チェック（採用） | 堅牢、明示的 | 2 行必要 | 採用 |
| パイプ（`ps -q \| grep -q .`） | 1 行 | `pipefail` でエラー伝播 | 見送り |
| `set +e` で一時的に無効化 | シンプル | 安全性が低下 | 見送り |

### 3. `basename $(pwd)` によるプロジェクト名取得

場所: `justfile` の `dev-deps`、`clean` タスク

```bash
PROJECT_NAME=$(basename "$(pwd)")
docker compose -p "$PROJECT_NAME" ...
```

なぜこの実装か:

worktree のディレクトリ名は `ringiflow-<name>` 形式で、そのまま Docker Compose のプロジェクト名として適切。固定値ではなくディレクトリ名から動的に取得することで、メイン worktree でも追加 worktree でも同じ `justfile` で正しく動作する。

代替案:

| 案 | メリット | デメリット | 判断 |
|----|---------|-----------|------|
| `basename $(pwd)`（採用） | 動的、設定不要 | ディレクトリ名に依存 | 採用 |
| `.env` に `PROJECT_NAME` を記載 | 明示的 | 手動設定が必要 | 見送り |
| `docker compose` のデフォルト名 | 設定不要 | YAML ファイルの場所に依存 | 見送り |

## 関連ドキュメント

- [機能解説](./01_機能解説.md)
- ADR: [021_並行開発環境の構成](../../05_ADR/021_並行開発環境の構成.md)
- ナレッジベース: [git_worktree](../../06_ナレッジベース/devtools/git_worktree.md)
- 手順書: [並行開発（Worktree）](../../04_手順書/04_開発フロー/04_並行開発（Worktree）.md)
