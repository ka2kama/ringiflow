# ID 設計規約

## 概要

本ドキュメントは、RingiFlow における識別子（ID）の実装仕様を定義する。

決定の背景・代替案との比較については [ADR-001: ID 形式の選定](../05_ADR/001_ID形式の選定.md) を参照。

## ID 形式

| 用途 | UUID バージョン | 特徴 |
|------|----------------|------|
| 参照系（マスタデータ） | UUID v4 | ランダム、ソート不要 |
| 時系列系（運用データ） | UUID v7 | タイムスタンプ含有、ソート可能 |

---

## ID 分類

### 参照系 ID（UUID v4）

時系列が意味を持たない、安定したマスタデータの識別子。

| エンティティ | 型名 | 説明 |
|-------------|------|------|
| テナント | `TenantId` | マルチテナント分離キー |
| ユーザー | `UserId` | ユーザー識別子 |
| ロール | `RoleId` | ロール定義 |
| 権限 | `PermissionId` | 権限定義 |
| ワークフロー定義 | `WorkflowDefinitionId` | ワークフローテンプレート |

### 時系列系 ID（UUID v7）

作成順でのソートが有用な運用データの識別子。

| エンティティ | 型名 | 説明 |
|-------------|------|------|
| イベント | `EventId` | Event Sourcing のイベント |
| コマンド | `CommandId` | CQRS のコマンド（冪等性キー） |
| ワークフローインスタンス | `WorkflowInstanceId` | 実行中のワークフロー |
| タスク | `TaskId` | 承認タスク |
| ドキュメント | `DocumentId` | アップロードドキュメント |
| 通知 | `NotificationId` | ユーザー通知 |
| 監査ログ | `AuditLogId` | 監査証跡 |

---

## 実装

### ディレクトリ構成

```
packages/domain/src/
├── id/
│   ├── mod.rs           # ID モジュールエクスポート
│   ├── base.rs          # 共通トレイト・マクロ
│   ├── reference.rs     # 参照系 ID（v4）
│   └── temporal.rs      # 時系列系 ID（v7）
└── ...
```

### 依存クレート

```toml
# Cargo.toml
[dependencies]
uuid = { version = "1", features = ["v4", "v7", "serde"] }
serde = { version = "1", features = ["derive"] }
thiserror = "2"
```

### 基盤実装

```rust
// packages/domain/src/id/base.rs

use std::str::FromStr;
use uuid::Uuid;

/// ID 型の共通エラー
#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]
pub enum IdError {
    #[error("無効な UUID 形式: {0}")]
    InvalidFormat(String),

    #[error("UUID バージョン不一致: 期待={expected}, 実際={actual}")]
    VersionMismatch { expected: u8, actual: u8 },
}

/// ID 型の共通トレイト
pub trait DomainId: Sized + Clone + Copy + PartialEq + Eq + std::hash::Hash {
    /// 内部の UUID を取得
    fn as_uuid(&self) -> Uuid;

    /// UUID から復元（バージョン検証なし）
    fn from_uuid_unchecked(uuid: Uuid) -> Self;

    /// 文字列から復元
    fn parse(s: &str) -> Result<Self, IdError> {
        let uuid = Uuid::from_str(s)
            .map_err(|_| IdError::InvalidFormat(s.to_string()))?;
        Ok(Self::from_uuid_unchecked(uuid))
    }
}
```

### 参照系 ID マクロ

```rust
/// 参照系 ID（v4）を定義するマクロ
#[macro_export]
macro_rules! define_reference_id {
    ($(#[$meta:meta])* $name:ident) => {
        $(#[$meta])*
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[derive(serde::Serialize, serde::Deserialize)]
        #[serde(transparent)]
        pub struct $name(uuid::Uuid);

        impl $name {
            /// 新しい ID を生成（UUID v4）
            pub fn new() -> Self {
                Self(uuid::Uuid::new_v4())
            }
        }

        impl Default for $name {
            fn default() -> Self {
                Self::new()
            }
        }

        impl $crate::id::base::DomainId for $name {
            fn as_uuid(&self) -> uuid::Uuid {
                self.0
            }

            fn from_uuid_unchecked(uuid: uuid::Uuid) -> Self {
                Self(uuid)
            }
        }

        impl std::fmt::Display for $name {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{}", self.0)
            }
        }

        impl std::str::FromStr for $name {
            type Err = $crate::id::base::IdError;

            fn from_str(s: &str) -> Result<Self, Self::Err> {
                <Self as $crate::id::base::DomainId>::parse(s)
            }
        }
    };
}
```

### 時系列系 ID マクロ

```rust
/// 時系列系 ID（v7）を定義するマクロ
#[macro_export]
macro_rules! define_temporal_id {
    ($(#[$meta:meta])* $name:ident) => {
        $(#[$meta])*
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
        #[derive(serde::Serialize, serde::Deserialize)]
        #[serde(transparent)]
        pub struct $name(uuid::Uuid);

        impl $name {
            /// 新しい ID を生成（UUID v7）
            pub fn new() -> Self {
                Self(uuid::Uuid::now_v7())
            }

            /// タイムスタンプを取得（ミリ秒）
            pub fn timestamp_ms(&self) -> Option<u64> {
                self.0.get_timestamp().map(|ts| {
                    let (secs, nanos) = ts.to_unix();
                    secs * 1000 + (nanos / 1_000_000) as u64
                })
            }
        }

        impl Default for $name {
            fn default() -> Self {
                Self::new()
            }
        }

        impl $crate::id::base::DomainId for $name {
            fn as_uuid(&self) -> uuid::Uuid {
                self.0
            }

            fn from_uuid_unchecked(uuid: uuid::Uuid) -> Self {
                Self(uuid)
            }
        }

        impl std::fmt::Display for $name {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{}", self.0)
            }
        }

        impl std::str::FromStr for $name {
            type Err = $crate::id::base::IdError;

            fn from_str(s: &str) -> Result<Self, Self::Err> {
                <Self as $crate::id::base::DomainId>::parse(s)
            }
        }
    };
}
```

### ID 定義例

```rust
// packages/domain/src/id/reference.rs
use crate::define_reference_id;

define_reference_id!(
    /// テナント識別子
    TenantId
);

define_reference_id!(
    /// ユーザー識別子
    UserId
);

// packages/domain/src/id/temporal.rs
use crate::define_temporal_id;

define_temporal_id!(
    /// イベント識別子
    EventId
);

define_temporal_id!(
    /// タスク識別子
    TaskId
);
```

### モジュールエクスポート

```rust
// packages/domain/src/id/mod.rs

pub mod base;
pub mod reference;
pub mod temporal;

pub use base::{DomainId, IdError};
pub use reference::*;
pub use temporal::*;
```

---

## 使用方法

### 生成

```rust
// 参照系: UUID v4
let tenant_id = TenantId::new();
let user_id = UserId::new();

// 時系列系: UUID v7
let event_id = EventId::new();
let task_id = TaskId::new();

// 時系列系はタイムスタンプを取得可能
if let Some(ts) = event_id.timestamp_ms() {
    println!("Created at: {} ms", ts);
}
```

### 型安全性

```rust
fn approve_task(task_id: TaskId, approver_id: UserId) -> Result<(), Error> {
    // ...
}

let task = TaskId::new();
let user = UserId::new();

approve_task(task, user);      // OK
approve_task(user, task);      // コンパイルエラー
```

### 文字列との変換

```rust
// ID → 文字列
let id = TaskId::new();
let s = id.to_string();  // "018e5e6c-7f5a-7b3d-8f1a-2b3c4d5e6f7a"

// 文字列 → ID
let id: TaskId = "018e5e6c-7f5a-7b3d-8f1a-2b3c4d5e6f7a".parse()?;
```

### API ハンドラでの使用

```rust
async fn get_task(
    Path(task_id): Path<String>,
) -> Result<Json<Task>, ApiError> {
    let task_id: TaskId = task_id.parse()
        .map_err(|_| ApiError::InvalidId)?;
    // ...
}
```

---

## データベース連携

### SQLx 型マッピング

```rust
impl sqlx::Type<sqlx::Postgres> for TaskId {
    fn type_info() -> sqlx::postgres::PgTypeInfo {
        <uuid::Uuid as sqlx::Type<sqlx::Postgres>>::type_info()
    }
}

impl<'r> sqlx::Decode<'r, sqlx::Postgres> for TaskId {
    fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, sqlx::error::BoxDynError> {
        let uuid = <uuid::Uuid as sqlx::Decode<sqlx::Postgres>>::decode(value)?;
        Ok(Self::from_uuid_unchecked(uuid))
    }
}

impl sqlx::Encode<'_, sqlx::Postgres> for TaskId {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> sqlx::encode::IsNull {
        self.as_uuid().encode_by_ref(buf)
    }
}
```

### PostgreSQL スキーマ

```sql
CREATE TABLE tasks (
    id UUID PRIMARY KEY,                              -- TaskId (v7)
    tenant_id UUID NOT NULL REFERENCES tenants(id),   -- TenantId (v4)
    workflow_instance_id UUID NOT NULL,               -- WorkflowInstanceId (v7)
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_tasks_tenant ON tasks(tenant_id);
CREATE INDEX idx_tasks_workflow ON tasks(workflow_instance_id);
```

---

## 表示用 ID

### 概要

UUID はシステム用の一意識別子として維持しつつ、人間が口頭・チャットで参照しやすい**表示用 ID**（例: `WF-42`）を補助的に付与する。

決定の背景については [ADR-029: 人間向け表示用 ID の導入](../05_ADR/029_人間向け表示用IDの導入.md) を参照。
詳細な実装仕様については [12_表示用ID設計.md](12_表示用ID設計.md) を参照。

### 二重 ID 体系

| ID | 用途 | 例 | 保存先 |
|----|------|-----|--------|
| UUID（主キー） | システム識別、URL、FK | `018e5e6c-7f5a-...` | `id` カラム |
| 表示用 ID | 人間向け表示、口頭伝達 | `WF-42` | `display_number` カラム + アプリ層でプレフィックス結合 |

### 対象エンティティ

| エンティティ | プレフィックス | DB カラム | スコープ |
|-------------|--------------|-----------|---------|
| ワークフローインスタンス | `WF` | `display_number` (BIGINT) | テナント単位 |
| ワークフローステップ | `STEP` | `display_number` (BIGINT) | テナント単位 |

### 設計原則

1. UUID 主キーは変更しない（FK、URL、分散生成の利点を維持）
2. DB には数値（`display_number`）のみ保存し、プレフィックスはアプリ層で結合
3. 連番のスコープはテナント単位（テナント間の情報漏洩を防止）
4. 欠番を許容する（トランザクションロールバック時の一貫性を優先）
5. 表示用 ID による URL ルーティングは行わない（UUID を維持）

### 実装パターン

```rust
/// 表示用連番
pub struct DisplayNumber(i64);  // 1 以上の正の整数

/// 表示用 ID（プレフィックス + 連番）
pub struct DisplayId {
    prefix: &'static str,
    number: DisplayNumber,
}
// DisplayId::to_string() → "WF-42"
```

---

## セキュリティ考慮事項

### UUID v7 のタイムスタンプ

UUID v7 には作成時刻が含まれる。

| リスク | 対策 |
|--------|------|
| 作成時刻の推測 | 許容（`created_at` を返す設計と同等） |
| 列挙攻撃 | 74bit ランダム部で実質不可能 |
| 認可バイパス | ID の知識と認可は独立（テナント分離で防御） |

---

## コーディングガイドライン

### 推奨

```rust
// 型付き ID を使用
fn create_task(workflow_id: WorkflowInstanceId) -> TaskId { ... }

// new() で生成
let id = TaskId::new();

// parse() で外部入力を変換
let id: TaskId = input.parse()?;
```

### 非推奨

```rust
// 生の Uuid を使用しない
fn create_task(workflow_id: Uuid) -> Uuid { ... }  // NG

// 文字列のまま保持しない
struct Task {
    id: String,  // NG: TaskId を使う
}
```

---

## 関連ドキュメント

- [ADR-001: ID 形式の選定](../05_ADR/001_ID形式の選定.md) - 主キー形式の決定
- [ADR-029: 人間向け表示用 ID の導入](../05_ADR/029_人間向け表示用IDの導入.md) - 表示用 ID の決定
- [12_表示用ID設計.md](12_表示用ID設計.md) - 表示用 ID の詳細設計

---

## 変更履歴

| 日付 | 変更内容 | 担当 |
|------|---------|------|
| 2026-01-13 | 初版作成 | - |
| 2026-01-13 | WHY を ADR に分離、HOW に特化 | - |
| 2026-02-01 | 表示用 ID セクション追加 | - |
