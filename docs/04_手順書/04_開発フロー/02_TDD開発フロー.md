# TDD é–‹ç™ºãƒ•ãƒ­ãƒ¼

## æ¦‚è¦

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ TDDï¼ˆãƒ†ã‚¹ãƒˆé§†å‹•é–‹ç™ºï¼‰ã‚’æ¡ç”¨ã—ã€ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆã§å®Ÿè£…ã‚’é€²ã‚ã‚‹ã€‚
t_wadaï¼ˆå’Œç”°å“äººï¼‰ã® TDD æ‰‹æ³•ã‚’åŸºæœ¬ã¨ã—ã€ã‚¢ã‚¸ãƒ£ã‚¤ãƒ«çš„ã« MVP ã‚’ç©ã¿ä¸Šã’ã‚‹ã€‚

### æ¡ç”¨ç†ç”±

| è¦³ç‚¹ | TDD ã®ãƒ¡ãƒªãƒƒãƒˆ |
|------|---------------|
| å“è³ª | ãƒã‚°ã®æ—©æœŸç™ºè¦‹ã€ãƒªã‚°ãƒ¬ãƒƒã‚·ãƒ§ãƒ³é˜²æ­¢ |
| è¨­è¨ˆ | ãƒ†ã‚¹ãƒˆã—ã‚„ã™ã„è¨­è¨ˆ = è‰¯ã„è¨­è¨ˆ |
| å­¦ç¿’ | å°ã•ãªã‚¹ãƒ†ãƒƒãƒ—ã§ç€å®Ÿã«ç†è§£ã‚’æ·±ã‚ã‚‰ã‚Œã‚‹ |
| å®‰å¿ƒ | å‹•ãã‚³ãƒ¼ãƒ‰ã‚’å¸¸ã«ç¶­æŒã€å¤§èƒ†ãªãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ãŒå¯èƒ½ |

---

## TDD ã‚µã‚¤ã‚¯ãƒ«

```mermaid
flowchart LR
    R["ğŸ”´ Red"] --> G["ğŸŸ¢ Green"]
    G --> RF["ğŸ”µ Refactor"]
    RF --> R
```

### ğŸ”´ Red: å¤±æ•—ã™ã‚‹ãƒ†ã‚¹ãƒˆã‚’æ›¸ã

**ç›®çš„:** å®Ÿè£…ã™ã¹ãæŒ¯ã‚‹èˆã„ã‚’æ˜ç¢ºã«ã™ã‚‹

1. ãƒ†ã‚¹ãƒˆã‚’1ã¤ã ã‘æ›¸ã
2. ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’è§£æ¶ˆã™ã‚‹ï¼ˆæœ€å°é™ã®ã‚¹ã‚¿ãƒ–ï¼‰
3. ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦ **å¤±æ•—ã™ã‚‹ã“ã¨ã‚’ç¢ºèª** ã™ã‚‹

```rust
#[tokio::test]
async fn test_find_user_by_email_returns_user_when_exists() {
    // Arrange
    let repo = setup_test_repository().await;

    // Act
    let result = repo.find_by_email(&tenant_id, &email).await;

    // Assert
    assert!(result.is_ok());
    assert!(result.unwrap().is_some());
}
```

é‡è¦: å¤±æ•—ã‚’ç¢ºèªã›ãšã«å®Ÿè£…ã«é€²ã¾ãªã„ã€‚å¤±æ•—ã‚’è¦‹ã‚‹ã“ã¨ã§ï¼š
- ãƒ†ã‚¹ãƒˆãŒæ­£ã—ãæ›¸ã‘ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã§ãã‚‹
- å®Ÿè£…å‰å¾Œã®å·®åˆ†ãŒæ˜ç¢ºã«ãªã‚‹

### ğŸŸ¢ Green: æœ€çŸ­ã§é€šã™

**ç›®çš„:** ãƒ†ã‚¹ãƒˆã‚’é€šã™æœ€å°é™ã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã

1. **ä»®å®Ÿè£…ï¼ˆFake Itï¼‰:** å®šæ•°ã‚’è¿”ã™ãªã©ã€æœ€ã‚‚å˜ç´”ãªå®Ÿè£…
2. **æ˜ç™½ãªå®Ÿè£…ï¼ˆObvious Implementationï¼‰:** ç­”ãˆãŒæ˜ã‚‰ã‹ãªã‚‰ç›´æ¥å®Ÿè£…
3. ã‚³ãƒ¼ãƒ‰ã®ç¾ã—ã•ã¯å¾Œå›ã—

```rust
// ä»®å®Ÿè£…ã®ä¾‹ï¼ˆã¾ãšã“ã‚Œã§ãƒ†ã‚¹ãƒˆã‚’é€šã™ï¼‰
pub async fn find_by_email(&self, tenant_id: &TenantId, email: &Email) -> Result<Option<User>> {
    Ok(Some(User::new(/* ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã¨åŒã˜å€¤ */)))
}
```

é‡è¦: ã“ã®æ®µéšã§ã¯ã€Œå‹•ãã€ã“ã¨ã ã‘ã«é›†ä¸­ã€‚é‡è¤‡ã‚„æ±šã„ã‚³ãƒ¼ãƒ‰ã¯è¨±å®¹ã™ã‚‹ã€‚

### ğŸ”µ Refactor: ãã‚Œã„ã«ã™ã‚‹

**ç›®çš„:** å‹•ä½œã‚’å¤‰ãˆãšã«ã‚³ãƒ¼ãƒ‰ã‚’æ”¹å–„ã™ã‚‹

1. é‡è¤‡ã‚’é™¤å»
2. å‘½åã‚’æ”¹å–„
3. æ§‹é€ ã‚’æ•´ç†
4. **ãƒ†ã‚¹ãƒˆãŒé€šã‚Šç¶šã‘ã‚‹ã“ã¨ã‚’ç¢ºèªã—ãªãŒã‚‰** é€²ã‚ã‚‹

```rust
// ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å¾Œï¼ˆå®Ÿéš›ã®DBå•ã„åˆã‚ã›ï¼‰
pub async fn find_by_email(&self, tenant_id: &TenantId, email: &Email) -> Result<Option<User>> {
    let row = sqlx::query_as!(
        UserRow,
        "SELECT * FROM users WHERE tenant_id = $1 AND email = $2",
        tenant_id.as_uuid(),
        email.as_str()
    )
    .fetch_optional(&self.pool)
    .await?;

    Ok(row.map(User::from))
}
```

---

## ãƒ†ã‚¹ãƒˆãƒªã‚¹ãƒˆ

å®Ÿè£…å‰ã«ãƒ†ã‚¹ãƒˆãƒªã‚¹ãƒˆï¼ˆTODO ãƒªã‚¹ãƒˆï¼‰ã‚’ä½œæˆã™ã‚‹ã€‚ã“ã‚ŒãŒå®Ÿè£…ã®é“æ¨™ã«ãªã‚‹ã€‚

### ä½œæˆã®ã‚³ãƒ„

1. **å®Œäº†åŸºæº–ã‹ã‚‰é€†ç®—:** Issue ã®å®Œäº†åŸºæº–ã‚’ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã«åˆ†è§£
2. **æ­£å¸¸ç³» â†’ ç•°å¸¸ç³»:** ã¾ãšå‹•ãå ´åˆã€æ¬¡ã«å¤±æ•—ã™ã‚‹å ´åˆ
3. **å¢ƒç•Œå€¤:** ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã‚’å¿˜ã‚Œãšã«
4. **å„ªå…ˆé †ä½ä»˜ã‘:** æœ€ã‚‚ä¾¡å€¤ã®ã‚ã‚‹ãƒ†ã‚¹ãƒˆã‹ã‚‰

### ä¾‹: ãƒ­ã‚°ã‚¤ãƒ³æ©Ÿèƒ½

```markdown
## ãƒ†ã‚¹ãƒˆãƒªã‚¹ãƒˆ

### UserRepository
- [ ] ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—ã§ãã‚‹
- [ ] å­˜åœ¨ã—ãªã„ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å ´åˆ None ã‚’è¿”ã™
- [ ] åˆ¥ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯å–å¾—ã§ããªã„

### PasswordHasher
- [ ] ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œè¨¼ã§ãã‚‹ï¼ˆæ­£ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼‰
- [ ] ä¸æ­£ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯æ¤œè¨¼å¤±æ•—

### SessionManager
- [ ] ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ä½œæˆã§ãã‚‹
- [ ] ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å–å¾—ã§ãã‚‹
- [ ] ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤ã§ãã‚‹
- [ ] å­˜åœ¨ã—ãªã„ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯ None ã‚’è¿”ã™

### AuthUseCase
- [ ] æ­£ã—ã„èªè¨¼æƒ…å ±ã§ãƒ­ã‚°ã‚¤ãƒ³ã§ãã‚‹
- [ ] ä¸æ­£ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã§ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—
- [ ] å­˜åœ¨ã—ãªã„ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—
- [ ] éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ãƒ­ã‚°ã‚¤ãƒ³ä¸å¯
```

### é€²ã‚æ–¹

1. ãƒªã‚¹ãƒˆã®æœ€åˆã®é …ç›®ã‚’é¸ã¶
2. Red â†’ Green â†’ Refactor
3. å®Œäº†ã—ãŸã‚‰ãƒã‚§ãƒƒã‚¯ã‚’ä»˜ã‘ã‚‹ âœ…
4. æ¬¡ã®é …ç›®ã¸
5. æ–°ã—ã„ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’æ€ã„ã¤ã„ãŸã‚‰ãƒªã‚¹ãƒˆã«è¿½åŠ 

---

## MVP ç©ã¿ä¸Šã’æ–¹å¼

ã‚¢ã‚¸ãƒ£ã‚¤ãƒ«çš„ã«ã€å‹•ãæœ€å°å˜ä½ã‹ã‚‰æ®µéšçš„ã«æ©Ÿèƒ½ã‚’è¿½åŠ ã™ã‚‹ã€‚

### åŸå‰‡

| åŸå‰‡ | èª¬æ˜ |
|------|------|
| å‚ç›´ã‚¹ãƒ©ã‚¤ã‚¹ | 1ã¤ã®æ©Ÿèƒ½ã‚’ç«¯ã‹ã‚‰ç«¯ã¾ã§å‹•ã‹ã™ |
| å¸¸ã«å‹•ãçŠ¶æ…‹ | å„ã‚¹ãƒ†ãƒƒãƒ—å®Œäº†æ™‚ç‚¹ã§å‹•ä½œç¢ºèªã§ãã‚‹ |
| ä¾å­˜é †ã«ç©ã‚€ | ä¸‹ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰é †ã«å®Ÿè£… |

### ä¾å­˜é–¢ä¿‚ã‚’è€ƒæ…®ã—ãŸé †åº

```mermaid
flowchart TB
    subgraph Layer1["Layer 1: ã‚¤ãƒ³ãƒ•ãƒ©"]
        A["UserRepository"]
        B["PasswordHasher"]
        C["SessionManager"]
    end

    subgraph Layer2["Layer 2: ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹"]
        D["AuthUseCase"]
    end

    subgraph Layer3["Layer 3: API"]
        E["Core API Handler"]
        F["BFF Handler"]
    end

    A --> D
    B --> D
    D --> E
    C --> F
    E --> F
```

**å®Ÿè£…é †åº:**
1. UserRepositoryï¼ˆDB ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—ï¼‰
2. PasswordHasherï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ¤œè¨¼ï¼‰
3. AuthUseCaseï¼ˆèªè¨¼ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
4. Core API Handlerï¼ˆå†…éƒ¨ APIï¼‰
5. SessionManagerï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ï¼‰
6. BFF Handlerï¼ˆå…¬é–‹ APIï¼‰

å„ã‚¹ãƒ†ãƒƒãƒ—ã§ã€Œãƒ†ã‚¹ãƒˆ â†’ å®Ÿè£… â†’ ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã€ã‚’ç¹°ã‚Šè¿”ã™ã€‚

---

## å®Ÿè·µçš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³

### ãƒ‘ã‚¿ãƒ¼ãƒ³1: ä¸‰è§’æ¸¬é‡ï¼ˆTriangulationï¼‰

1ã¤ã®ãƒ†ã‚¹ãƒˆã ã‘ã§ã¯ä¸€èˆ¬åŒ–ã—ã«ãã„å ´åˆã€è¤‡æ•°ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’è¿½åŠ ã—ã¦å®Ÿè£…ã‚’å°ãã€‚

```rust
// ãƒ†ã‚¹ãƒˆ1
#[test]
fn test_verify_password_returns_true_for_correct_password() {
    let hasher = Argon2PasswordHasher::new();
    let hash = hasher.hash("password123").unwrap();
    assert!(hasher.verify("password123", &hash).unwrap());
}

// ãƒ†ã‚¹ãƒˆ2ï¼ˆä¸‰è§’æ¸¬é‡ï¼‰
#[test]
fn test_verify_password_returns_false_for_wrong_password() {
    let hasher = Argon2PasswordHasher::new();
    let hash = hasher.hash("password123").unwrap();
    assert!(!hasher.verify("wrongpassword", &hash).unwrap());
}
```

### ãƒ‘ã‚¿ãƒ¼ãƒ³2: Given-When-Thenï¼ˆAAAï¼‰

ãƒ†ã‚¹ãƒˆã®æ§‹é€ ã‚’æ˜ç¢ºã«ã™ã‚‹ã€‚

```rust
#[tokio::test]
async fn test_login_succeeds_with_valid_credentials() {
    // Givenï¼ˆArrangeï¼‰: å‰ææ¡ä»¶
    let repo = MockUserRepository::new();
    let hasher = MockPasswordHasher::new();
    let usecase = AuthUseCase::new(repo, hasher);

    // Whenï¼ˆActï¼‰: å®Ÿè¡Œ
    let result = usecase.authenticate(&email, &password).await;

    // Thenï¼ˆAssertï¼‰: æ¤œè¨¼
    assert!(result.is_ok());
}
```

### ãƒ‘ã‚¿ãƒ¼ãƒ³3: ãƒ†ã‚¹ãƒˆãƒ€ãƒ–ãƒ«

ä¾å­˜ã‚’å·®ã—æ›¿ãˆã¦å˜ä½“ãƒ†ã‚¹ãƒˆã‚’å¯èƒ½ã«ã™ã‚‹ã€‚

| ç¨®é¡ | ç”¨é€” |
|------|------|
| Stub | å›ºå®šå€¤ã‚’è¿”ã™ |
| Mock | å‘¼ã³å‡ºã—ã‚’æ¤œè¨¼ |
| Fake | ç°¡æ˜“ç‰ˆã®å®Ÿè£…ï¼ˆã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªDBãªã©ï¼‰ |

```rust
// Fake å®Ÿè£…ã®ä¾‹
pub struct InMemoryUserRepository {
    users: HashMap<Email, User>,
}

impl UserRepository for InMemoryUserRepository {
    async fn find_by_email(&self, _tenant_id: &TenantId, email: &Email) -> Result<Option<User>> {
        Ok(self.users.get(email).cloned())
    }
}
```

---

## ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å…¨ä½“åƒ

```mermaid
flowchart TD
    A["Issue ã®å®Œäº†åŸºæº–ã‚’ç¢ºèª"] --> B["ãƒ†ã‚¹ãƒˆãƒªã‚¹ãƒˆã‚’ä½œæˆ"]
    B --> C["æœ€åˆã®ãƒ†ã‚¹ãƒˆã‚’é¸æŠ"]
    C --> D["ğŸ”´ Red: ãƒ†ã‚¹ãƒˆã‚’æ›¸ã"]
    D --> E["ğŸŸ¢ Green: å®Ÿè£…ã™ã‚‹"]
    E --> F["ğŸ”µ Refactor: æ•´ç†ã™ã‚‹"]
    F --> G{"ãƒ†ã‚¹ãƒˆãƒªã‚¹ãƒˆ<br/>å®Œäº†ï¼Ÿ"}
    G -->|No| C
    G -->|Yes| H["çµ±åˆãƒ†ã‚¹ãƒˆã§å‹•ä½œç¢ºèª"]
    H --> I["PR ä½œæˆ"]
```

---

## ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

å®Ÿè£…å®Œäº†æ™‚ã«ç¢ºèªã™ã‚‹é …ç›®:

- [ ] ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆãŒé€šã‚‹ï¼ˆ`cargo test`ï¼‰
- [ ] ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ãŒå¦¥å½“ï¼ˆä¸»è¦ãƒ‘ã‚¹ã‚’ç¶²ç¾…ï¼‰
- [ ] ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ãŒå®Œäº†ã—ã¦ã„ã‚‹
- [ ] çµ±åˆãƒ†ã‚¹ãƒˆã§ E2E ã®å‹•ä½œã‚’ç¢ºèª
- [ ] `just check-all` ãŒé€šã‚‹

---

## å‚è€ƒè³‡æ–™

- ã€ãƒ†ã‚¹ãƒˆé§†å‹•é–‹ç™ºã€Kent Beck è‘—ã€å’Œç”°å“äºº è¨³
- t_wada ã®ã‚¹ãƒ©ã‚¤ãƒ‰ãƒ»è¬›æ¼”è³‡æ–™
- [ãƒ†ã‚¹ãƒˆé§†å‹•é–‹ç™ºã«ã¤ã„ã¦ã¾ã¨ã‚ã¦ã¿ãŸ](https://qiita.com/t_wada/items/e2b3b1a5b9e89a5b7f9c)

---

## å¤‰æ›´å±¥æ­´

| æ—¥ä»˜ | å¤‰æ›´å†…å®¹ |
|------|---------|
| 2026-01-17 | åˆç‰ˆä½œæˆ |
