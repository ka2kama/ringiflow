# ADR-003: Elm ルーティングフレームワークの選定

## ステータス

承認済み（2026-01-14）

## コンテキスト

RingiFlow のフロントエンドは Elm + The Elm Architecture (TEA) で構築する。SPA として複数のページ（16 画面を予定）を持ち、URL ベースのルーティングが必要となる。

Elm のルーティング実装には以下のアプローチがある:

1. **手動実装**: `elm/url` の `Url.Parser` を使って自前でルーティングを構築
2. **elm-spa**: ファイルベースルーティングを提供するフレームワーク
3. **elm-land**: elm-spa v7 相当の後継フレームワーク

### プロジェクトの制約・目的

- **学習目的**: 本プロジェクトの第一目的は Elm/TEA の深い理解
- **Ports 要件の複雑さ**: 要件定義書で WebSocket 再接続、楽観的 UI 更新、再同期など複雑な Ports 連携を規定
- **Phase 1 MVP の規模**: 7 画面程度（SCR-001〜008 のうち 7 画面）

## 検討した選択肢

### 選択肢 1: 手動実装（elm/url + Url.Parser）

`Browser.application` と `Url.Parser` を使い、ルーティングを自前で実装する。

```elm
-- Route.elm
type Route
    = Home
    | Workflows
    | WorkflowDetail WorkflowId
    | NotFound

parser : Parser (Route -> a) a
parser =
    oneOf
        [ Parser.map Home top
        , Parser.map Workflows (s "workflows")
        , Parser.map WorkflowDetail (s "workflows" </> string)
        ]
```

評価:
- 利点:
  - TEA の仕組みを深く理解できる（学習効果最大）
  - Ports 連携を完全に自由設計できる
  - 外部依存なし（elm/url は標準ライブラリ）
  - 後から他のアプローチへ移行可能
- 欠点:
  - ページ追加時に複数箇所を修正（Route.elm, Main.elm）
  - ボイラープレートが増える
  - ページモジュールの構造化は自己責任

### 選択肢 2: elm-spa

Ryan Haskell-Glatz が作成したフレームワーク。ファイルベースルーティング（Next.js 風）を Elm で実現する。

```
src/Pages/
├── Home_.elm       → /
├── Workflows.elm   → /workflows
└── Workflows/Id_.elm → /workflows/:id
```

評価:
- 利点:
  - ファイル追加だけでルート自動生成
  - 認証ガード等の共通処理を統一的に扱える
  - 規約に沿えばスケールしやすい
- 欠点:
  - elm-spa CLI への依存
  - フレームワークの規約に従う必要がある
  - Ports 設計に制約が生じる可能性
  - TEA の内部動作が抽象化され、学習機会が減る

### 選択肢 3: elm-land

elm-spa の後継（v7 相当）。より洗練された API と改善された開発体験を提供。

評価:
- 利点:
  - elm-spa より改善された設計
  - アクティブに開発されている
- 欠点:
  - elm-spa と同様の欠点
  - 比較的新しく、エコシステムがまだ発展途上
  - 日本語情報が少ない

### 比較表

| 観点 | 手動実装 | elm-spa | elm-land |
|------|---------|---------|----------|
| 学習効果 | 高 | 低 | 低 |
| ボイラープレート | 多い | 少ない | 少ない |
| Ports 設計の自由度 | 高 | 中 | 中 |
| 外部依存 | なし | CLI | CLI |
| スケーラビリティ | 要設計 | 高 | 高 |
| 移行コスト（後から） | - | 中 | 中 |
| 日本語情報 | 多い | 少ない | 非常に少ない |

## 決定

**選択肢 1: 手動実装**を採用する。

理由:

1. **学習効果の最大化**: プロジェクトの第一目的は学習であり、TEA の仕組みを手で触ることで理解が深まる
2. **Ports 要件との整合性**: 要件定義書で規定した複雑な Ports/WebSocket 設計を、フレームワークの制約なく実装できる
3. **Phase 1 の規模**: MVP は 7 画面程度であり、手動実装で十分に管理可能
4. **後から移行可能**: 手動実装で限界を感じた場合、elm-spa/elm-land への移行は後からでも可能

### 補足: ページモジュールパターンの採用

手動実装でも構造化は行う。各ページを独立したモジュールとして設計する:

```elm
-- Pages/Workflows.elm
module Pages.Workflows exposing (Model, Msg, init, update, view)

-- Main.elm
type Page
    = WorkflowsPage Pages.Workflows.Model
    | ...

update msg model =
    case ( msg, model.page ) of
        ( WorkflowsMsg subMsg, WorkflowsPage subModel ) ->
            let
                ( newSubModel, cmd ) = Pages.Workflows.update subMsg subModel
            in
            ( { model | page = WorkflowsPage newSubModel }
            , Cmd.map WorkflowsMsg cmd
            )
```

これにより、elm-spa の利点（ページの独立性）を維持しつつ、学習効果も確保できる。

## 帰結

### 肯定的な影響

- TEA の Model-Update-View サイクルを深く理解できる
- Ports 連携（WebSocket、楽観的 UI 更新）を自由に設計できる
- 外部 CLI への依存がなく、ビルドプロセスがシンプル
- 将来的なフレームワーク採用の判断材料が得られる

### 否定的な影響・トレードオフ

- ページ追加時のボイラープレートが増える
- ルーティングの型安全性を自分で保証する必要がある
- 認証ガード等の共通処理を自前で設計する必要がある

### 再検討のトリガー

以下の状況になった場合、elm-spa/elm-land の採用を再検討する:

- ページ数が 20 を超え、手動管理が困難になった場合
- ルーティング関連のバグが頻発する場合
- チームメンバーが増え、規約の統一が必要になった場合

### 関連ドキュメント

- 要件定義書: [`docs/01_要件定義書/02_アーキテクチャ設計.md`](../01_要件定義書/02_アーキテクチャ設計.md) [5.3.1 Elm / Ports 連携要件]
- 実装: [`apps/web/src/Route.elm`](../../apps/web/src/Route.elm)
- 実装: [`apps/web/src/Main.elm`](../../apps/web/src/Main.elm)

---

## 変更履歴

| 日付 | 変更内容 |
|------|---------|
| 2026-01-14 | 初版作成 |
