# ローカル検証性

## 概要

ローカル検証性（Local Verifiability）とは、開発者が手元の環境で任意のシナリオを再現し、動作を確認できる度合いのこと。

> 原則: ローカルや開発環境で動作確認が取れない設計は、設計不足である。

自動テスト（Automated Testing）と手動の動作確認（Manual Verification）は補完関係にあり、両方が機能して初めて「検証できている」と言える。

## 自動テストと手動確認の違い

| | 自動テスト | 手動動作確認 |
|---|---|---|
| 目的 | 回帰防止、仕様の担保 | 「本当にこう動く」という確信 |
| 状態準備 | テストコードで自動セットアップ | 開発者が手動で状態を作る |
| 実行 | CI / コマンド | 開発者が操作する |
| 強み | 再現性、網羅性 | 探索的な検証、予期しない挙動の発見 |

自動テストだけでは「テストが通るから大丈夫」という過信に陥りうる。手動確認だけでは回帰を防げない。両輪で品質を担保する。

## アンチパターン: 祈りデプロイ

「状態の再現コストが高すぎて検証を諦め、修正が正しいことを祈ってリリースする」パターン。

```mermaid
flowchart LR
    A["状態の再現が困難"] --> B["動作確認を省略"] --> C["えいやでリリース"] --> D["天に祈る"]
```

### 根本原因: 制御性の欠如

ソフトウェアテストにおける **制御性（Controllability）** と **観測性（Observability）** は、テスト容易性の2本柱として知られる（ハードウェアテストの DFT: Design for Testability に由来）。

| 柱 | 定義 | 欠如した場合 |
|----|------|-------------|
| 制御性 | システムを任意の状態に設定できる度合い | 特定の状態を再現できず、検証を諦める |
| 観測性 | システムの内部状態を確認できる度合い | 動作したか分からず、結果を祈る |

祈りデプロイの根本原因は、状態空間が大きいのに **特定の状態にジャンプする手段（制御性）がない** こと。

## 制御性を確保する設計パターン

状態空間の制御性を確保する手段は複数あり、対象の性質に応じて選択する。

| パターン | 概要 | 適する場面 |
|---------|------|-----------|
| シナリオスクリプト | 一連の API 呼び出しで特定の状態を作るスクリプト | 状態遷移のある業務フロー |
| 状態スナップショット | 各状態のシードデータを用意する | DB 依存の状態 |
| Dev-only エンドポイント | 状態遷移をスキップして任意の中間状態にジャンプ | Web アプリケーション |
| 遅延注入 | タイミング依存の挙動を再現可能にする（例: `pg_sleep`） | 並行処理、競合条件 |
| フィーチャフラグ | 特定のコードパスを有効/無効にする | 段階的リリース |

重要なのは **設計段階で** 制御性を考慮すること。後付けで検証手段を追加するのは、設計の継ぎ接ぎになりやすい。

## ringiflow での適用

### 並行処理・競合条件

楽観的ロック（version check）が正しく機能するかは、自動テスト（並行更新テスト）と手動確認（競合エラーの UI 表示）の両方で検証すべき。

| 検証対象 | 自動テスト | 手動確認 |
|---------|-----------|---------|
| 同一ステップへの同時承認 | `tokio::spawn` で並行更新、片方が Conflict | シナリオスクリプトで並行リクエスト送信 |
| トランザクションの原子性 | テスト内で部分失敗を模擬、不変条件を検証 | — |
| エラーメッセージの適切さ | — | UI 上で競合エラーの文言を確認 |

#### 競合条件の手動確認における課題

競合条件は本質的に **タイミング依存** であり、開発者一人が手動で同時操作を再現するのは物理的に困難。2 つのブラウザを同時にクリックしても、数ミリ秒のウィンドウを突くのは現実的でない。

これは「制御性が足りない」典型例であり、以下のアプローチで対処する:

| アプローチ | 仕組み | 利点 |
|-----------|--------|------|
| 並行リクエストスクリプト | 複数の HTTP リクエストを同時送信するスクリプト | タイミングを人間から切り離す |
| 遅延注入 | トランザクション内に意図的な遅延を挿入し、競合ウィンドウを広げる | 確実に競合を再現できる |
| 自動テストに委ねる | `tokio::spawn` で並行更新を実行 | 再現性が最も高い |

競合の **検出ロジック** は自動テストで確実に検証し、競合発生時の **ユーザー体験**（エラー表示、リカバリ導線）は遅延注入で手動確認する、という使い分けが有効。

### ワークフロー状態遷移

多段階承認フローで「途中の状態」を確認するのに、毎回手動で step1 → step2 → ... と進めるのは制御性が低い。

対策例:
- シナリオスクリプト: `just scenario-step2-active` で step2 がアクティブな状態を一発で作る
- 状態バリエーションのシードデータ: Draft、InProgress（step1）、InProgress（step2）、差し戻し済み等

## 既知手法との関連

| 概念 | 出典 | 本記事との関連 |
|------|------|---------------|
| Controllability / Observability | ハードウェア DFT（Design for Testability）から派生 | 検証性の2本柱 |
| Testability | ISO/IEC 25010 保守性のサブ特性 | 自動テストの容易さ |
| Operability | ISO/IEC 25010 操作性のサブ特性 | 手動確認のしやすさ |
| Shift-left Testing | テスト工程を開発初期に前倒しする考え方 | 設計段階で検証手段を組み込む |
| Seams | Feathers, M. (2004) "Working Effectively with Legacy Code" | コードの振る舞いを制御可能な接合点 |

## 判断基準

新しい機能や状態遷移を設計する際のセルフチェック:

1. この機能の各状態に、ローカル環境で到達できるか？
2. 異常系（エラー、競合、タイムアウト）をローカルで再現できるか？
3. 再現手段は文書化されているか（暗黙知になっていないか）？

いずれかが No の場合、制御性の改善を検討する。ただし「今すぐ対処する」か「将来の Issue として記録する」かは、現時点のリスクと工数で判断する。

## 参考文献

- Feathers, M. (2004) "Working Effectively with Legacy Code", Prentice Hall
  - テスト容易性のための設計パターン（Seam の概念）
- Whittaker, J. A. (2009) "Exploratory Software Testing", Addison-Wesley
  - 探索的テストと手動検証の価値
- ISO/IEC 25010:2023 Systems and software Quality Requirements and Evaluation (SQuaRE)
  - Testability、Operability の定義

## 関連

- [SRE 的アプローチ](SRE的アプローチ.md) — Observability（観測性）の概念
- [ISO 25010](ISO25010.md) — 品質特性モデル
- [エンティティ影響マップ: WorkflowInstance](../../03_詳細設計書/エンティティ影響マップ/WorkflowInstance.md) — 競合リスクの分析

---

## 変更履歴

| 日付 | 変更内容 |
|------|---------|
| 2026-02-19 | 初版作成 |
