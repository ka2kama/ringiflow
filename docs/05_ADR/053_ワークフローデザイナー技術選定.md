# ADR-053: ワークフローデザイナー技術選定

## ステータス

承認済み（2026-02-20）

## コンテキスト

Phase 2-4 でワークフローデザイナー（SCR-006）を実装する。テナント管理者が GUI でワークフロー定義を作成できる機能であり、以下の UI 要素が必要になる:

- キャンバス上にステップ（ノード）を配置・移動する
- ステップ間を接続線（エッジ）で結ぶ
- ステップを選択してプロパティを編集する

技術的に決定が必要な事項:

1. キャンバスの描画方式（SVG / HTML Canvas / HTML DOM）
2. ドラッグ&ドロップの実装方式（ブラウザ D&D API / マウスイベント / Ports）

プロジェクトのフロントエンドは Elm（TEA アーキテクチャ）で実装されており、JavaScript との連携は Ports を介して行う。

## 検討した選択肢

### 判断1: キャンバスの描画方式

#### 選択肢 A: SVG + Elm 直接レンダリング

Elm の `Svg` モジュール（`elm/svg` 1.0.1、既にインストール済み）で SVG 要素を直接レンダリングする。ノードは `<rect>` + `<text>`、エッジは `<line>` や `<path>` で描画する。

評価:

- 利点:
  - SVG は HTML と同じ Virtual DOM で扱えるため、Elm の宣言的 UI パラダイムと自然に統合される
  - `<line>`, `<path>`, `<marker>` で接続線・矢印を直接描画できる
  - 各 SVG 要素にイベントハンドラを直接付与できる（`onClick`, `onMouseDown` 等）
  - 追加の外部ライブラリが不要
  - SVG の知識はデータ可視化等にも応用でき、学習効果が高い
- 欠点:
  - ノード数が多い場合のパフォーマンスに注意が必要（数百ノード規模で DOM 操作がボトルネックになる可能性）
  - 複雑なインタラクション（ベジェ曲線エディタ等）を自前実装する必要がある

#### 選択肢 B: HTML Canvas + JavaScript ライブラリ

Konva.js や Fabric.js 等の Canvas ライブラリを Ports 経由で操作する。キャンバスの状態管理は JavaScript 側で行い、Elm は Ports でコマンドを送受信する。

評価:

- 利点: Canvas はピクセル単位の描画が可能で、大量のノードでもパフォーマンスが安定する
- 欠点:
  - Elm の Virtual DOM と独立した状態管理が JavaScript 側に生まれ、状態の二重管理になる
  - すべてのインタラクションが Ports 経由になり、通信コストが増大する
  - ライブラリ固有の API に依存し、学習の汎用性が低い
  - Canvas 要素には DOM イベントが付与できないため、ヒットテスト（座標→ノード判定）をライブラリに依存する

#### 選択肢 C: HTML DOM + CSS absolute

Elm で通常の HTML 要素（`div`）を `position: absolute` で配置し、CSS でスタイリングする。接続線は SVG オーバーレイまたは CSS で描画する。

評価:

- 利点: Elm で自然にレンダリングでき、スタイリングは CSS で柔軟に対応できる
- 欠点:
  - 接続線の描画が本質的に困難。結局 SVG オーバーレイが必要になり、選択肢 A と同等の複雑さで、かつ HTML と SVG のレイヤーが分離する問題が加わる
  - ノード位置の管理に `position: absolute` と `transform` の座標変換が必要で、キャンバスのパン・ズームが複雑になる

### 判断2: ドラッグ&ドロップの実装方式

#### 選択肢 D: ブラウザ Drag and Drop API

HTML5 の Drag and Drop API（`draggable`, `ondragstart`, `ondragover`, `ondrop`）を使用する。

評価:

- 欠点: SVG 要素ではブラウザの Drag and Drop API のサポートが不完全（ブラウザ間の差異が大きい）。ドラッグ中のビジュアルフィードバック制御も困難。**SVG 描画方式と組み合わせる場合は不適切。**

#### 選択肢 E: Elm マウスイベント

Elm の `onMouseDown`（SVG 要素）+ `Browser.Events.onMouseMove` / `onMouseUp`（グローバル subscription）で dragging 状態を Model で管理する。

評価:

- 利点:
  - TEA アーキテクチャに自然に統合される（dragging 状態は Model、イベントは Msg、描画は View）
  - SVG 要素のマウスイベントは全ブラウザで安定して動作する
  - `Browser.Events.onMouseMove` は Elm 標準パッケージ（`elm/browser` 1.0.2、既にインストール済み）
  - Ports 不要でテスタビリティが高い
- 欠点: グローバル subscription の登録・解除を dragging 状態に連動させる必要がある（`subscriptions` 関数で制御）

#### 選択肢 F: Ports 経由の JavaScript D&D

JavaScript 側で D&D ロジックを実装し、Ports で座標情報を Elm に送信する。

評価:

- 欠点: Elm 側の Model と JavaScript 側の D&D 状態の二重管理が発生する。選択肢 B と同様の問題。

## 決定

**判断1: 選択肢 A（SVG + Elm 直接レンダリング）を採用する。**

**判断2: 選択肢 E（Elm マウスイベント）を採用する。**

理由:

1. **Elm との統合**: SVG は Virtual DOM で扱えるため、TEA の Model → View → Update サイクルに完全に統合される。D&D もマウスイベントで Elm 側に閉じるため、状態の二重管理が発生しない
2. **接続線の自然な描画**: SVG の `<line>` / `<path>` でステップ間の矢印を直接描画できる。HTML DOM では追加のオーバーレイレイヤーが必要
3. **外部依存の最小化**: `elm/svg` と `elm/browser` はいずれも既にインストール済みで、追加の外部ライブラリが不要
4. **学習効果**: SVG の仕組みとマウスイベントベースの D&D パターンは、データ可視化やインタラクティブ UI に広く応用できる汎用的スキル
5. **品質（保守性）**: すべての状態が Elm の Model に集約され、型安全性とテスタビリティが確保される

### Ports の役割（最小限）

D&D ロジック自体は Elm 側で完結させる。Ports は以下の補助的な役割のみ:

- キャンバス要素の寸法取得（`Element.getBoundingClientRect()`）— マウス座標をキャンバス座標に変換するために必要

### パフォーマンスに関する判断

Phase 2-4 のスコープ（順次承認のみ）では、1 つのワークフロー定義に含まれるステップ数は 10 個程度が上限と想定される（開始 1 + 承認 2〜3 + 終了 2〜3）。この規模では SVG の DOM 操作がボトルネックになることはない。

将来的にノード数が増加する場合（Phase 3 以降の条件分岐・並列承認）は、仮想化（viewport 外のノードを非レンダリング）等の最適化を検討する。

## 影響

- `elm/svg` — 既存パッケージの活用（追加インストール不要）
- `Browser.Events` — プロジェクト初使用。`subscriptions` 関数でマウスイベントのグローバル subscription を管理する
- `Ports` — 既存の `Ports.elm` / `main.js` にキャンバス寸法取得用の Port を追加する
- フロントエンドのモジュール構成 — `Page/WorkflowDefinition/` 以下に Designer 関連モジュールを追加する

## 参照

- 要件: WFD-001（キャンバス）、WFD-003（接続線）
- Elm SVG モジュール: https://package.elm-lang.org/packages/elm/svg/latest/
- Elm Browser.Events: https://package.elm-lang.org/packages/elm/browser/latest/Browser-Events
- 既存の Ports パターン: `frontend/src/Ports.elm`, `frontend/src/main.js`
