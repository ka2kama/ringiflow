# ADR-029: 人間向け表示用 ID の導入

## ステータス

承認済み（2026-02-01）

## コンテキスト

RingiFlow では [ADR-001](001_ID形式の選定.md) の決定に基づき、すべてのエンティティの主キーに UUID（v4 / v7）を使用している。UUID はシステム的には優れているが、運用上は以下の課題がある:

1. 口頭での伝達が事実上不可能（「018e5e6c-7f5a...の申請を確認してください」）
2. メール・チャットでの言及がコピペ前提
3. ユーザーが「さっきの申請」を ID で特定できない

Jira（`PROJ-123`）や GitHub（`#196`）のように、**システム用 UUID + 人間用連番**の二重 ID パターンはエンタープライズ向けワークフローシステムでは事実上の標準である。

### ADR-001 との関係

ADR-001 では選択肢 7「BIGSERIAL + UUID（内部/外部分離）」を却下している。しかし、これは**主キー構造**に関する議論であった:

| 観点 | ADR-001 の議論 | 今回の提案 |
|------|---------------|-----------|
| 対象 | 主キーの形式 | 補助フィールドの追加 |
| UUID の役割 | 外部公開用 ID | 主キー（変更なし） |
| 連番の役割 | 内部主キー（FK、JOIN） | 人間向け表示専用 |
| FK の影響 | FK を内部 ID にするか外部 ID にするか曖昧 | FK は UUID のまま（影響なし） |

今回の提案は UUID 主キーを維持したまま、人間向けの補助フィールドを追加する設計であり、ADR-001 の決定と矛盾しない。

### スコープの検討: グローバル vs テナント単位

マルチテナント SaaS において、連番のスコープは重要な設計判断である。

| スコープ | 特徴 |
|---------|------|
| グローバル連番 | 全テナント共通の通し番号。シンプルだがテナント間で作成数が推測可能 |
| テナント単位連番 | テナントごとに `WF-1` から開始。情報漏洩リスクなし。各テナントにとって自然な番号体系 |

テナント単位連番を採用する。理由:

1. マルチテナント SaaS として自然な設計（各テナントが自社の番号体系を持つ）
2. グローバル連番ではテナント間の利用状況が推測可能（情報漏洩リスク）
3. 各テナントにとって番号が小さく直感的（`WF-3` vs `WF-15482`）

### プレフィックスの検討

| 方式 | 例 | 特徴 |
|------|-----|------|
| 固定プレフィックス | `WF-123` | シンプル。アプリ側で結合 |
| テナントカスタマイズ | `稟議-123` | 柔軟だが複雑。MVP では過剰 |
| プレフィックスなし | `#123` | 最もシンプルだがエンティティ種別が不明 |

固定プレフィックスを採用する。理由:

1. MVP に最適なシンプルさ
2. DB には数値のみ保存し、プレフィックスはアプリ層で結合（プレフィックス変更が容易）
3. 将来のカスタマイズ対応への拡張余地あり

## 検討した選択肢

### 選択肢 1: カウンターテーブル + SELECT FOR UPDATE

テナント×エンティティ種別ごとにカウンター行を持ち、`SELECT FOR UPDATE` で排他制御する。

```sql
CREATE TABLE display_id_counters (
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    entity_type VARCHAR(50) NOT NULL,
    last_number BIGINT NOT NULL DEFAULT 0,
    PRIMARY KEY (tenant_id, entity_type)
);
```

採番フロー:
```sql
BEGIN;
SELECT last_number FROM display_id_counters
    WHERE tenant_id = $1 AND entity_type = $2
    FOR UPDATE;
-- last_number + 1 を取得
UPDATE display_id_counters
    SET last_number = last_number + 1
    WHERE tenant_id = $1 AND entity_type = $2;
-- 対象テーブルに INSERT（display_number = last_number + 1）
COMMIT;
```

評価:
- 利点: DDL 不要（INSERT のみでテナント追加）、標準的な SQL、トランザクション整合性が明確、KISS
- 欠点: 行ロックによる直列化（同一テナント・同一エンティティの同時採番がボトルネック）

### 選択肢 2: テナント別 PostgreSQL SEQUENCE

テナントごとに PostgreSQL の SEQUENCE オブジェクトを動的生成する。

```sql
-- テナント追加時
CREATE SEQUENCE wf_display_seq_tenant_abc START 1;

-- 採番時
SELECT nextval('wf_display_seq_tenant_abc');
```

評価:
- 利点: PostgreSQL ネイティブの採番、トランザクション外で発番（ロック競合なし）
- 欠点: DDL 操作がテナント追加のたびに必要、SEQUENCE 管理が煩雑（テナント数 × エンティティ種別）、テナント削除時に SEQUENCE の掃除が必要

### 選択肢 3: UUID v7 タイムスタンプ短縮表示

UUID v7 のタイムスタンプ部分を短縮表示する（例: `WF-26B01-A3F`）。

評価:
- 利点: 追加テーブル不要、採番競合なし
- 欠点: 人間にとって覚えにくい（連番の方が直感的）、同一ミリ秒の衝突解決が必要、口頭伝達の課題を根本解決しない

### 選択肢 4: カウンターテーブル + Advisory Lock

選択肢 1 の変形。`SELECT FOR UPDATE` の代わりに PostgreSQL の Advisory Lock を使用する。

```sql
SELECT pg_advisory_xact_lock(hashtext($tenant_id || ':' || $entity_type));
UPDATE display_id_counters SET last_number = last_number + 1 WHERE ...;
```

評価:
- 利点: 行ロックより軽量（ロックマネージャーのみ）、高スループット
- 欠点: Advisory Lock は PostgreSQL 固有（DB 移行時のリスク）、ロックキーの衝突管理が必要（ハッシュ衝突）、選択肢 1 と比べて複雑さに見合うメリットが現時点では薄い

### 比較表

| 観点 | カウンター + FOR UPDATE | テナント別 SEQUENCE | UUID v7 短縮 | カウンター + Advisory Lock |
|------|----------------------|-------------------|-------------|--------------------------|
| シンプルさ | ◎ | △ | ○ | ○ |
| テナント追加の容易さ | ◎（INSERT） | △（DDL） | ◎（不要） | ◎（INSERT） |
| 同時実行性能 | ○ | ◎ | ◎ | ◎ |
| 人間への分かりやすさ | ◎（連番） | ◎（連番） | △ | ◎（連番） |
| DB ポータビリティ | ◎ | △ | ◎ | △ |
| トランザクション整合性 | ◎ | △（ギャップ） | ◎ | ◎ |
| 運用の複雑さ | ◎ | △ | ◎ | ○ |

## 決定

選択肢 1: カウンターテーブル + SELECT FOR UPDATE を採用する。

### 採用理由

1. KISS 原則: 標準的な SQL のみで実装可能。DDL の動的生成や PostgreSQL 固有機能に依存しない。テナント追加は INSERT 1行で完了する。

2. トランザクション整合性: `SELECT FOR UPDATE` はトランザクション内で動作するため、対象テーブルへの INSERT と一貫性を保てる。ロールバック時にカウンターも巻き戻る。

3. 想定規模で十分な性能: RingiFlow の想定規模（3年後 500 テナント、10万ユーザー）では、同一テナントの同時ワークフロー作成頻度は低い。行ロックの直列化がボトルネットになる可能性は極めて低い。

### 却下理由

- テナント別 SEQUENCE: DDL の動的生成はテナントライフサイクル管理を複雑にする。SEQUENCE はトランザクション外で発番するため欠番が発生しやすい。シンプルさに欠ける。
- UUID v7 短縮表示: 口頭伝達の課題を根本解決しない。「WF-26B01-A3F を確認して」は「WF-42 を確認して」より明らかに劣る。
- Advisory Lock: 現時点の規模では `SELECT FOR UPDATE` との性能差は無視できる。PostgreSQL 固有機能への依存を増やす理由がない。将来スケールが課題になった場合のマイグレーションパスとして記録に留める。

## 帰結

### 肯定的な影響

- ユーザーがワークフローやタスクを口頭・チャットで簡潔に参照可能になる（「WF-42 を確認してください」）
- UUID 主キーの利点（分散生成、推測困難）を維持したまま、UX を改善
- 標準的な SQL のみで実装され、特殊な DB 機能に依存しない
- テナント単位の連番により、テナント間の情報漏洩リスクがない

### 否定的な影響・トレードオフ

- カウンターテーブルの管理が追加される（テナント作成時にカウンター行を初期化する必要）
- 同一テナント・同一エンティティの同時採番は直列化される（想定規模では問題にならない）
- 既存データへのマイグレーションが必要（既存の workflow_instances に display_number を割り当てる）
- API レスポンスに `display_id` フィールドが追加される（破壊的変更ではない）

### 将来の拡張パス

- 性能がボトルネットになった場合: Advisory Lock（選択肢 4）への移行が容易
- テナントカスタマイズが必要になった場合: `display_id_counters` にプレフィックスカラムを追加
- 対象エンティティの拡大: `entity_type` カラムで任意のエンティティに対応済み

### 関連ドキュメント

- 設計書: [04_ID設計規約.md](../03_詳細設計書/04_ID設計規約.md) - 表示用 ID セクション追加
- 設計書: [12_表示用ID設計.md](../03_詳細設計書/12_表示用ID設計.md) - 詳細設計
- ADR: [001_ID形式の選定.md](001_ID形式の選定.md) - 主キー形式の決定（本 ADR の前提）

---

## 変更履歴

| 日付 | 変更内容 |
|------|---------|
| 2026-02-01 | 初版作成 |
