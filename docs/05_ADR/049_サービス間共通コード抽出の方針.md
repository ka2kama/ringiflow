# ADR-049: サービス間共通コード抽出の方針

## ステータス

承認済み

## コンテキスト

Epic #467（jscpd 警告ゼロ）の Story #530 において、3 つのサービス（BFF, Core Service, Auth Service）間のコードクローン 13 件への対処方針を決定する必要がある。

先行 Story（#525-#529, #533）でサービス内クローンの削減が完了しており、残る課題はサービス境界を跨いだ重複である。As-Is 検証の結果、13 件のうち 2 件は先行 Story で解消済み、5 件はテストコード（#531 スコープ）であり、プロダクションコードで対処が必要な 4 件を評価した。

サービス間の共通化には、マイクロサービスの独立性とのトレードオフがある。共通化は変更の同期コストを下げるが、サービス間の結合度を上げる。共通化しない場合は独立性を保てるが、変更の同期漏れが起こりうる。

## 検討した選択肢

### クローン 1: Health Check ハンドラ（auth ↔ core、BFF も類似）

#### 選択肢 1-A: HealthResponse 型のみ shared に抽出

HealthResponse 型（status, version の 2 フィールド）を shared crate に移動し、handler 関数は各サービスに残す。

評価:
- 利点: shared に axum 依存を追加しない。shared の設計方針（外部クレート依存の最小化）を維持。`env!("CARGO_PKG_VERSION")` が各サービスの crate で正しく展開される
- 欠点: handler 関数本体（5 行程度）が各サービスで重複する

#### 選択肢 1-B: HealthResponse 型 + handler 関数を shared に抽出

型と handler 関数の両方を shared に移動する。

評価:
- 利点: 完全な DRY
- 欠点: shared に axum 依存が必要。shared の設計方針に反する。`env!("CARGO_PKG_VERSION")` が shared の version を返してしまう

### クローン 2: main.rs 起動コード（3 サービスで酷似）

#### 選択肢 2-A: jscpd:ignore で意図的重複をマーク

`// jscpd:ignore-start` / `// jscpd:ignore-end` コメントで、起動コードを意図的な重複として除外する。

評価:
- 利点: 可読性を損なわない。各サービスの起動コードが自己完結。subscriber 設定がアプリ層の責務として明確
- 欠点: 変更時に 3 箇所の同期が必要（ただし起動コードは安定しており変更頻度は極めて低い）

#### 選択肢 2-B: 共通関数を shared に抽出

tracing init, dotenvy 読み込みを共通関数にする。

評価:
- 利点: 完全な DRY
- 欠点: shared に tracing-subscriber, dotenvy 依存が必要。subscriber 設定はアプリ層の責務であり、ライブラリ層の shared に置くべきではない（ADR-023 のレイヤー構造に反する）

#### 選択肢 2-C: proc macro で起動コード生成

マクロで起動ボイラープレートを生成する。

評価:
- 利点: 単一定義
- 欠点: 過度な抽象化。macro の可読性が低い。起動コードの変更頻度に対してコストが不釣り合い

### クローン 3: BFF auth_service.rs HTTP match パターン

HTTP ステータスコードのパターンマッチが 2 箇所で類似。

評価:
- jscpd で検出されていない（閾値未満または差異あり）
- 2 回の重複は「3 回まで許容」の原則内

### クローン 4: BFF types ↔ Core handler レスポンス型

BFF のクライアント型と Core Service のハンドラレスポンス型が類似。

評価:
- jscpd で検出されていない
- マイクロサービスの独立性を優先。BFF の型は UI 最適化のために自由に変更できるべき

### 比較表

| 観点 | 1-A: 型のみ抽出 | 1-B: 型+handler 抽出 | 2-A: jscpd:ignore | 2-B: 共通関数 | 2-C: macro |
|------|----------------|---------------------|-------------------|--------------|------------|
| shared の依存増 | なし | axum 追加 | なし | tracing-subscriber 等追加 | proc-macro crate 追加 |
| レイヤー整合性 | 維持 | shared にアプリ層の責務 | 維持 | shared にアプリ層の責務 | 維持 |
| DRY 達成度 | 型のみ | 完全 | 意図的除外 | 完全 | 完全 |
| 可読性 | 良好 | 良好 | 良好 | 良好 | macro のため低下 |
| env! 正確性 | 各 crate で展開 | shared の version | N/A | N/A | 呼び出し元で展開 |

## 決定

4 つのクローンに対して以下のように決定する。

### クローン 1: 選択肢 1-A（型のみ抽出）を採用

HealthResponse 型を shared crate に抽出し、handler 関数は各サービスに残す。

理由:
1. shared に axum 依存を追加しない（shared の設計方針: 外部クレート依存の最小化）
2. `env!("CARGO_PKG_VERSION")` が各サービスの crate で正しく展開される
3. 残る handler 関数本体は 5 行程度であり、jscpd の `--min-lines 10` 閾値を下回るため検出されない

### クローン 2: 選択肢 2-A（jscpd:ignore）を採用

main.rs の起動コードに `// jscpd:ignore-start` / `// jscpd:ignore-end` を付与し、意図的重複として除外する。

理由:
1. tracing-subscriber の設定はアプリ層の責務であり、ライブラリ層の shared に置くべきではない（ADR-023 のレイヤー構造）
2. 起動コードは安定したボイラープレートで変更頻度が極めて低く、DRY が排除すべき「変更の同期が必要な重複」ではない
3. 各サービスの main.rs が自己完結することで、独立したデプロイ・設定変更が容易

### クローン 3, 4: 対処不要

理由:
1. jscpd で検出されていない（閾値未満または差異あり）
2. クローン 3 は 2 回の重複で「3 回まで許容」の原則内
3. クローン 4 はマイクロサービスの独立性を優先（BFF の型は UI 最適化のために独立して変更可能であるべき）

## 帰結

### 肯定的な影響

- jscpd による Health Check ハンドラのクローン検出が解消される
- main.rs の起動コードが意図的重複として明示され、jscpd 検出から除外される
- shared crate の依存が最小限に保たれる（axum, tracing-subscriber を追加しない）
- 各サービスのレイヤー構造が ADR-023 に準拠した状態を維持する

### 否定的な影響・トレードオフ

- handler 関数本体（5 行）は各サービスで重複が残る（jscpd 閾値以下のため実害なし）
- main.rs の起動パターン変更時に 3 箇所の同期が必要（変更頻度が極めて低いためリスクは低い）
- jscpd:ignore の追加により、将来その範囲内に新たな意味のある重複が紛れ込む可能性がある（コードレビューで防止）

### 関連ドキュメント

- Issue: #530（サービス間共通コード抽出）、Epic #467（jscpd 警告ゼロ）
- ADR: [ADR-023](023_バックエンドアーキテクチャパターンの選択.md)（レイヤー構造）、[ADR-042](042_コピペ検出ツールの選定.md)（jscpd 導入）
- 実装: `backend/crates/shared/src/health.rs`（HealthResponse 型）

---

## 変更履歴

| 日付 | 変更内容 |
|------|---------|
| 2026-02-16 | 初版作成 |
