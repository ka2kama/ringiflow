# ADR-054: ADT ベース状態マシンパターンの標準化

## ステータス

承認済み

## コンテキスト

### 背景

#793 で、ワークフローデザイナー画面の初期ロード時にノードがドラッグできないバグが発生した。原因は、フラットな Model にすべてのフィールドを持たせたことで、`loadState = Loading`（キャンバス未描画）の状態でキャンバス関連の操作（`requestCanvasBounds`）が発行可能だったこと。

```elm
-- #793 時点の Model（簡略化）
type alias Model =
    { loadState : RemoteData ApiError WorkflowDefinition
    , canvasBounds : Maybe Bounds     -- Loading 中は意味がない
    , steps : Dict String StepNode    -- Loading 中は意味がない
    , dragging : Maybe DraggingState  -- Loading 中は意味がない
    , ...  -- 約 20 のキャンバス関連フィールド
    }
```

このバグはフィールドの存在タイミングと状態の不一致に起因する。`canvasBounds` の `Maybe` は「非同期取得中（まだ来ていない）」と「状態として存在しない（Loading 中）」の 2 つの意味を混同していた。

### 問題

プロジェクトの設計原則に「型で表現できるものは型で表現する。不正な状態を表現不可能にする」がある。しかし、状態遷移に伴うフィールドの有効性について、この原則を適用する標準パターンが定まっていなかった。

類似の構造は他にも存在しうる:
- バックエンドでのリクエスト処理パイプライン（認証前/後で利用可能なデータが異なる）
- フロントエンドの他のページ（ロード前/後でフォーム状態が異なる）

### 既存の取り組み

プロジェクトでは既に型レベルの構造的強制を複数採用している:
- [ADR-016](016_プリミティブ型のNewtype化方針.md): Newtype パターンで型の取り違えを防止
- [ADR-051](051_トランザクションコンテキストによる構造的強制.md): TxContext でトランザクションなしの書き込みをコンパイルエラーに

本 ADR はこれらの延長線上にあり、状態遷移に伴う構造的強制のパターンを標準化する。

## 検討した選択肢

### 選択肢 1: 規約ベース（ギャップ発見の観点追加）

ギャップ発見の「状態網羅漏れ」の定義を拡張し、view だけでなく Cmd も対象に含める。設計レビューで検出する。

評価:
- 利点: 既存コードの変更不要。すぐに適用可能
- 欠点: 人的レビューに依存するため検出漏れのリスクがある。構造的強制ではない

### 選択肢 2: ADT ベース状態マシン

状態ごとに異なる型を定義し、各状態で有効なフィールドだけを持たせる。

```elm
-- フロントエンド（Elm）
type Model
    = Loading LoadingModel
    | Failed FailedModel
    | Loaded CanvasState

type alias CanvasState =
    { definition : WorkflowDefinition
    , canvasBounds : Maybe Bounds  -- この Maybe は「非同期取得中」の意味のみ
    , steps : Dict String StepNode
    , ...
    }
```

```rust
// バックエンド（Rust）
enum ProcessingState {
    Validating(ValidationContext),
    Executing(ExecutionContext),
    Completed(CompletedContext),
}
```

評価:
- 利点: 不正な状態が型レベルで表現不可能。各状態の update/view が明確に分離される。`Maybe` の意味が単一になる
- 欠点: リファクタリングコストがかかる（既存コードの分割）。状態間の共通フィールドの扱いに設計が必要

### 選択肢 3: Opaque Module による強制

選択肢 2 に加え、状態遷移関数を Opaque Module で公開し、遷移時の Cmd 発行を構造的に強制する。

```elm
module CanvasState exposing (CanvasState, fromDefinition, ...)
-- コンストラクタを非公開にし、fromDefinition が唯一の生成手段

fromDefinition : WorkflowDefinition -> ( CanvasState, Cmd msg )
fromDefinition def =
    ( { ... }, Ports.requestCanvasBounds canvasElementId )
```

評価:
- 利点: 最も強い構造的強制。遷移時の副作用（Cmd）も型レベルで保証
- 欠点: モジュール境界の設計が複雑化。小規模な状態遷移に対して過剰

### 比較表

| 観点 | 選択肢 1: 規約ベース | 選択肢 2: ADT 状態マシン | 選択肢 3: Opaque Module |
|------|---------------------|------------------------|----------------------|
| 不正状態の防止力 | 低（レビュー依存） | 高（型レベル） | 最高（構造的強制） |
| 導入コスト | 低 | 中 | 高 |
| 既存コードへの影響 | なし | リファクタリング必要 | リファクタリング + モジュール再設計 |
| 設計原則との整合 | △ | ○ | ◎ |
| 学習効果 | 低 | 高（ADT の実践） | 高（Opaque Module の実践） |

## 決定

選択肢 2: ADT ベース状態マシンをプロジェクト標準とし、選択肢 1 を補助として併用する。

選択肢 3（Opaque Module）は、状態遷移に必ず伴う副作用の強制が必要な場面で個別に検討する。

### 主な理由

1. 設計原則の直接的な実現: 「不正な状態を表現不可能にする」を状態遷移に適用する自然なパターン
2. 副次的メリット: フラットな大型 Model の整理、view/update の状態ごとの分離、`Maybe` の意味の明確化
3. 既存パターンとの一貫性: ADR-016（Newtype）、ADR-051（TxContext）と同じ「型による構造的強制」の系譜
4. 両言語で適用可能: Elm の Custom Type と Rust の enum は同じ ADT であり、統一的なパターンとして採用できる

### 適用基準

| 条件 | 適用 |
|------|------|
| 状態によって有効なフィールドが異なる | 適用する |
| 状態遷移が明確に定義されている | 適用する |
| 全状態でフィールドが同一（値だけ異なる） | 適用しない（enum フラグで十分） |
| 状態が 2 つで差異が小さい | 個別判断（コストに見合うか） |

### 設計ガイドライン

共通フィールドの扱い:

```elm
-- パターン A: 外側に共通フィールドを持つ（推奨）
type alias Model =
    { shared : Shared
    , definitionId : String
    , state : PageState
    }

type PageState
    = Loading
    | Failed ApiError
    | Loaded CanvasState
```

```rust
// パターン A: 外側に共通フィールドを持つ（推奨）
struct RequestContext {
    tenant_id: TenantId,
    state: RequestState,
}

enum RequestState {
    Authenticating,
    Authorized(AuthorizedContext),
}
```

`Maybe` / `Option` の意味の分離:

| 状態マシン適用前 | 状態マシン適用後 |
|----------------|----------------|
| `Maybe Bounds` = 「Loading 中で存在しない」or「非同期取得中」 | `Maybe Bounds` = 「非同期取得中」のみ |

## 帰結

### 肯定的な影響

- 状態に無関係なフィールドへのアクセスがコンパイルエラーになる
- 各状態の責務が型で明示され、コードの可読性が向上する
- ADR-016、ADR-051 と合わせて「型による構造的強制」がプロジェクト全体の一貫した方針になる
- Elm と Rust で同じパターンを適用でき、言語間の設計一貫性が高まる

### 否定的な影響・トレードオフ

- 既存のフラット Model のリファクタリングコスト（Designer.elm 等）
- 状態間のフィールド移動（例: 共通化 vs 分離）の設計判断が必要
- パターンマッチの深さが増す場合がある

### 今後必要になる作業

1. Designer.elm の Model を状態マシンにリファクタリングする（#793 の根本対策、別 Issue で管理）
2. ギャップ発見の「状態網羅漏れ」観点を拡張する（#795）
3. 他のページの Model で同様の構造がないか確認する（新規実装時に適用）
4. ナレッジベースに ADT 状態マシンの実装ガイドを追加する

### 関連ドキュメント

- Issue: #793（バグ）、#795（観点追加）
- ADR: [ADR-016](016_プリミティブ型のNewtype化方針.md)（Newtype）、[ADR-051](051_トランザクションコンテキストによる構造的強制.md)（TxContext）
- 設計原則: CLAUDE.md「型で表現できるものは型で表現する。不正な状態を表現不可能にする」

### 既知手法との関連

| 本 ADR の概念 | 既知手法 | 関係 |
|--------------|---------|------|
| ADT ベース状態マシン | Making Impossible States Impossible（Richard Feldman, 2016） | Elm コミュニティの確立パターン。本 ADR はこれをプロジェクト標準として明文化 |
| ADT ベース状態マシン | Typestate Pattern（Rust） | Rust での類似概念。ジェネリクスによる状態パラメータ化まではせず、enum による ADT を採用 |
| 規約 + 型の併用 | Defense in Depth | 選択肢 1（規約）を補助として残すのは多層防御の考え方 |

---

## 変更履歴

| 日付 | 変更内容 |
|------|---------|
| 2026-02-23 | 初版作成 |
