# ADR-055: バックエンドにおける動的ディスパッチ許容方針

## ステータス

承認済み

## コンテキスト

### 背景

Rust では静的ディスパッチ（ジェネリクス/モノモーフィゼーション）と動的ディスパッチ（トレイトオブジェクト `dyn Trait`）の 2 つの多態性手法がある。Rust コミュニティでは「ゼロコスト抽象化」の理念から静的ディスパッチが推奨される傾向にある。

しかし、本プロジェクトは Web アプリケーション（BFF / Core Service / Auth Service）であり、処理のボトルネックはネットワーク I/O やデータベースクエリにある。vtable lookup のコスト（数ナノ秒）は、これらの I/O レイテンシ（数ミリ秒〜数十ミリ秒）に対して無視できる。

### 現状

プロジェクトでは既に動的ディスパッチを広く活用している:

| パターン | 用途 | 参照 |
|---------|------|------|
| `Arc<dyn CoreServiceClient>` | サービスクライアントの抽象化 | [ADR-041](041_CoreServiceClientのサブトレイト分割.md) |
| `Arc<dyn CoreServiceUserClient>` 等 | ISP 適用後のサブトレイト | [ADR-041](041_CoreServiceClientのサブトレイト分割.md) |
| `Box<dyn TenantDeleter>` | リジストリパターン | `backend/crates/infra/src/deletion/` |
| `Arc<dyn TransactionManager>` | トランザクション管理 | [ADR-051](051_トランザクションコンテキストによる構造的強制.md) |

### 問題

動的ディスパッチを選択する際に「パフォーマンス劣化」を欠点として検討するかどうかが明文化されていなかった。ADR-051 では `Arc<dyn Repository>` との互換性を設計判断の根拠としているが、動的ディスパッチを積極的に許容する方針は明示されていない。

方針が不明確なまま個別判断を繰り返すと、以下のリスクがある:
- 設計レビューで「パフォーマンスは大丈夫か」という不要な議論が発生する
- ジェネリクスの方がパフォーマンスに優れるという理由だけで、コードの複雑さを受け入れてしまう

## 検討した選択肢

### 選択肢 1: 静的ディスパッチ優先（Rust コミュニティのデフォルト）

ジェネリクスをデフォルトとし、動的ディスパッチは「ジェネリクスでは実現困難な場合」に限定する。

評価:
- 利点: Rust コミュニティの慣習に沿う。コンパイラが最適化しやすい
- 欠点: ジェネリクスパラメータの増殖（generic parameter proliferation）が発生しやすい。型パラメータが関数シグネチャやステート構造体に伝播し、可読性が低下する。本プロジェクトではパフォーマンス差が無意味

### 選択肢 2: 動的ディスパッチ許容（型安全性を条件に）

型安全性を損なわない限り、動的ディスパッチを積極的に許容する。パフォーマンス劣化をデメリットとして扱わない。

評価:
- 利点: 設計のシンプルさを優先できる。ジェネリクスの増殖を回避できる。本プロジェクトの特性（Web アプリケーション）に合致する
- 欠点: Rust コミュニティの一般的な推奨とは異なる。`dyn Trait` の制約（object safety）を理解する必要がある

### 選択肢 3: 完全な動的ディスパッチ（ジェネリクス排除）

可能な限りすべてのトレイト境界を `dyn Trait` に置き換える。

評価:
- 利点: 一貫性が最大化される
- 欠点: ジェネリクスが適切な場面（イテレータ、コレクション操作等）でも動的ディスパッチを強いることになり、不自然。型パラメータによる静的な制約が活用できなくなる場面がある

### 比較表

| 観点 | 選択肢 1: 静的優先 | 選択肢 2: 動的許容 | 選択肢 3: 完全動的 |
|------|-------------------|-------------------|-------------------|
| 設計のシンプルさ | △（ジェネリクス増殖） | ○ | △（不自然な場面あり） |
| 型安全性 | ○ | ○ | △（静的制約を失う場面あり） |
| パフォーマンス | ○（本プロジェクトでは無意味） | ○（差は無視できる） | △ |
| Rust らしさ | ○ | ○ | × |
| 判断の明確さ | △（毎回判断が必要） | ○（方針が明確） | ○（方針が明確） |

## 決定

選択肢 2: 動的ディスパッチ許容（型安全性を条件に）を採用する。

### 主な理由

1. プロジェクト特性との合致: Web アプリケーションにおいて、vtable lookup のコストはボトルネックにならない。パフォーマンスを理由に設計を複雑にする合理性がない
2. 設計のシンプルさ: ジェネリクスパラメータの増殖を回避し、型パラメータがステート構造体や関数シグネチャに伝播する複雑さを抑える
3. 既存の実践との整合: ADR-041（サブトレイト分割）、ADR-051（トランザクション管理）で既に動的ディスパッチを設計判断の基盤としており、方針の明文化にあたる

### 適用基準

| 場面 | 判断 |
|------|------|
| DI（依存性注入）: リポジトリ、サービスクライアント等 | `Arc<dyn Trait>` を使用 |
| レジストリ・コレクション: 異なる実装の格納 | `Vec<Box<dyn Trait>>` 等を使用 |
| ローカルな型制約: 関数内やイテレータ操作 | ジェネリクスを使用（動的ディスパッチは不要） |
| object safety を満たさないトレイト | ジェネリクスを使用 |

### 条件

- 型安全性を損なわないこと。`dyn Any` へのダウンキャスト等、型情報を実行時に失う使い方は対象外
- object safety の要件を満たすこと（Sized 制約のないメソッド、ジェネリックメソッドを持たない等）

## 帰結

### 肯定的な影響

- 設計判断時に「パフォーマンス」を不要な検討軸から除外でき、判断がシンプルになる
- ジェネリクスパラメータの増殖を回避し、コードの可読性を維持できる
- ADR-041、ADR-051 の既存判断に一貫した根拠を与える

### 否定的な影響・トレードオフ

- Rust の一般的なガイドラインとは異なるため、外部から参加する開発者に方針の説明が必要
- object safety の制約を理解していないと、コンパイルエラーに遭遇する（学習コスト）
- 将来パフォーマンスクリティカルなコンポーネント（例: 大量データのバッチ処理）が追加された場合は、個別に再評価が必要

### 関連ドキュメント

- ADR: [ADR-041](041_CoreServiceClientのサブトレイト分割.md)（サブトレイト分割）、[ADR-051](051_トランザクションコンテキストによる構造的強制.md)（トランザクション管理）
- 設計原則: CLAUDE.md「型で表現できるものは型で表現する」

### 既知手法との関連

| 本 ADR の概念 | 既知手法 | 関係 |
|--------------|---------|------|
| 動的ディスパッチ許容 | Strategy Pattern (GoF) | GoF パターンの多くはインターフェースベース（= 動的ディスパッチ）で設計されている。本方針はこれらのパターンを Rust で自然に実装することを後押しする |
| パフォーマンスを理由にしない | Premature Optimization (Knuth) | 「早すぎる最適化は諸悪の根源」。測定なしにパフォーマンスを理由として設計を複雑にしない |
| 型安全性の条件 | Type Erasure vs Type Safety | Java の Type Erasure（ジェネリクスの実行時消去）のように型情報を完全に失うのとは異なり、`dyn Trait` はトレイトの契約を保持する。型安全性を条件とすることで、この境界を守る |

---

## 変更履歴

| 日付 | 変更内容 |
|------|---------|
| 2026-02-23 | 初版作成 |
