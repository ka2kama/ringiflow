# 並行開発環境 - コード解説

対応 PR: #96, #639

## 主要な型・関数

| 型/関数 | ファイル | 責務 |
|--------|---------|------|
| `create.sh` | [`scripts/worktree/create.sh`](../../../scripts/worktree/create.sh) | 永続スロット作成（detached HEAD + .env 生成 + セットアップ） |
| `switch.sh` | [`scripts/worktree/switch.sh`](../../../scripts/worktree/switch.sh) | スロット内ブランチ切り替え（DB マイグレーション + pnpm 差分更新） |
| `issue.sh` | [`scripts/worktree/issue.sh`](../../../scripts/worktree/issue.sh) | Issue 番号からブランチ名を自動生成し、`switch.sh` に委譲 |
| `cleanup.sh` | [`scripts/worktree/cleanup.sh`](../../../scripts/worktree/cleanup.sh) | 永続スロットをリセット（detached HEAD）、従来 worktree は削除 |
| `generate.sh` | [`scripts/env/generate.sh`](../../../scripts/env/generate.sh) | ポートオフセット付き `.env` ファイル生成 |
| `dev-deps` | [`justfile`](../../../justfile) | `basename $(pwd)` でプロジェクト名自動取得 → Docker Compose 起動 |
| `docker-compose.yaml` | [`infra/docker/docker-compose.yaml`](../../../infra/docker/docker-compose.yaml) | `container_name` なしでプロジェクト名分離対応 |

## コードフロー

コードをライフサイクル順に追う。各ステップの構造を図で示した後、対応するコードを解説する。

```mermaid
flowchart LR
    A["1. スロット作成<br/>（worktree-create.sh）"] --> B["2. ブランチ切り替え<br/>（worktree-switch.sh）"]
    B --> C["3. Issue ベースの切り替え<br/>（worktree-issue.sh）"]
    C --> D["4. .env 生成<br/>（generate-env.sh）"]
    D --> E["5. Docker 起動<br/>（プロジェクト名分離）"]
    E --> F["6. クリーンアップ<br/>（cleanup.sh）"]
```

### 1. スロット作成（worktree-create.sh）

永続スロットを初回作成する。detached HEAD で worktree を追加し、マーカーファイルと `.env` を生成する。

```mermaid
flowchart TB
    Validate["引数検証<br/>N ∈ {1..9}"] --> Exist{"既存チェック<br/>ディレクトリが<br/>存在する？"}
    Exist -->|Yes| Error["エラー終了"]
    Exist -->|No| Fetch["git fetch origin main"]
    Fetch --> Add["git worktree add<br/>--detach ../ringiflow-N origin/main"]
    Add --> Marker[".worktree-slot マーカー作成<br/>内容: N"]
    Marker --> Env["generate-env.sh N"]
    Env --> Setup["env -u ... just setup-worktree"]
```

```bash
# scripts/worktree/create.sh（主要部分）
N="$1"
if ! [[ "$N" =~ ^[1-9]$ ]]; then                         # ① スロット番号は 1-9 のみ
    echo "エラー: スロット番号は 1-9 の数字である必要があります" >&2
    exit 1
fi

WORKTREE_PATH="${PARENT_DIR}/ringiflow-${N}"

git fetch origin main --quiet
git worktree add --detach "$WORKTREE_PATH" origin/main    # ② detached HEAD で作成

echo "$N" > "$WORKTREE_PATH/.worktree-slot"               # ③ マーカーファイル

cd "$WORKTREE_PATH"
./scripts/env/generate.sh "$N"                            # ④ offset = スロット番号

env -u POSTGRES_PORT -u REDIS_PORT -u DYNAMODB_PORT \     # ⑤ 環境変数クリア
    -u API_TEST_POSTGRES_PORT -u API_TEST_REDIS_PORT -u API_TEST_DYNAMODB_PORT \
    -u BFF_PORT -u VITE_PORT \
    just setup-worktree
```

注目ポイント:

- ① 正規表現 `^[1-9]$` で厳密に検証。0 や 10 以上は拒否
- ② `--detach` で作成。`main` ブランチはメイン worktree が使用中のため、detached HEAD が適切。「スロット作成」と「ブランチ割当」の関心を分離する
- ③ `.worktree-slot` マーカーで永続スロットを識別。`cleanup.sh` がこのファイルの有無でリセット/削除を判定する
- ④ offset はスロット番号と同一の決定的マッピング。自動検出ロジックが不要になる
- ⑤ `env -u` で親プロセスから継承されたポート環境変数をクリア（→ [設計解説 1](#1-env--u-による環境変数クリア) 参照）

### 2. ブランチ切り替え（worktree-switch.sh）

スロット内で git switch を実行し、DB マイグレーションと pnpm 依存関係の差分更新を自動で行う。

```mermaid
flowchart TB
    Validate["引数検証 + スロット存在確認"] --> DirtyCheck{"未コミット変更<br/>あり？"}
    DirtyCheck -->|Yes| Error["エラー終了"]
    DirtyCheck -->|No| RecordHead["PREV_HEAD を記録"]
    RecordHead --> Fetch["git fetch origin"]
    Fetch --> Switch{"ブランチの存在"}
    Switch -->|ローカルに存在| Local["git switch BRANCH"]
    Switch -->|リモートのみ| Remote["git switch -c BRANCH origin/BRANCH"]
    Switch -->|新規| New["git switch -c BRANCH origin/main"]
    Local --> Migrate["just db-migrate"]
    Remote --> Migrate
    New --> Migrate
    Migrate --> DiffCheck{"pnpm-lock.yaml<br/>に差分あり？"}
    DiffCheck -->|Yes| Install["pnpm install<br/>（root + frontend + e2e）"]
    DiffCheck -->|No| Done["完了"]
    Install --> Done
```

```bash
# scripts/worktree/switch.sh（ブランチ切り替え部分）
PREV_HEAD=$(git -C "$WORKTREE_PATH" rev-parse HEAD 2>/dev/null || echo "")  # ①

git -C "$WORKTREE_PATH" fetch origin --quiet

if git -C "$WORKTREE_PATH" show-ref --verify "refs/heads/$BRANCH" >/dev/null 2>&1; then
    git -C "$WORKTREE_PATH" switch "$BRANCH"                                 # ② ローカル
elif git -C "$WORKTREE_PATH" ls-remote --exit-code origin "$BRANCH" >/dev/null 2>&1; then
    git -C "$WORKTREE_PATH" switch -c "$BRANCH" "origin/$BRANCH"             # ③ リモートのみ
else
    git -C "$WORKTREE_PATH" switch -c "$BRANCH" origin/main                  # ④ 新規
fi
```

注目ポイント:

- ① `PREV_HEAD` を切り替え前に記録。pnpm-lock.yaml の差分チェック（→ [設計解説 2](#2-pnpm-lockyaml-の差分チェックfail-open-方式) 参照）で使用する
- ② `show-ref --verify refs/heads/` でローカルブランチの存在を厳密にチェック（`rev-parse --verify` はタグも解決するため不適）
- ③ リモートのみに存在する場合は `-c` で追跡ブランチを作成
- ④ どちらにもなければ `origin/main` から新規ブランチを作成

```bash
# scripts/worktree/switch.sh（pnpm 差分チェック部分）
pnpm_changed=false
if [[ -n "$PREV_HEAD" ]]; then
    if ! git -C "$WORKTREE_PATH" diff --quiet "$PREV_HEAD"..HEAD -- \
        pnpm-lock.yaml frontend/pnpm-lock.yaml tests/e2e/pnpm-lock.yaml 2>/dev/null; then  # ①
        pnpm_changed=true
    fi
else
    pnpm_changed=true                                                        # ② fail-open
fi

if [[ "$pnpm_changed" == true ]]; then
    (cd "$WORKTREE_PATH" && pnpm install)                                    # ③
    (cd "$WORKTREE_PATH/frontend" && pnpm install)
    (cd "$WORKTREE_PATH/tests/e2e" && pnpm install)
fi
```

注目ポイント:

- ① 3 箇所の `pnpm-lock.yaml` を一括で差分チェック。1 つでも変更があれば install が必要
- ② `PREV_HEAD` が取得できない場合（初回切り替え等）は安全側に倒して install を実行
- ③ root、frontend、tests/e2e の 3 箇所でそれぞれ `pnpm install` を実行

### 3. Issue ベースの切り替え（worktree-issue.sh）

Issue 番号からブランチ名を自動生成し、`worktree-switch.sh` に委譲する。

```mermaid
flowchart TB
    Slot{"SLOT 引数<br/>あり？"}
    Slot -->|あり| UseSlot["指定値を使用"]
    Slot -->|なし| AutoDetect{".worktree-slot<br/>が存在？"}
    AutoDetect -->|Yes| ReadSlot["ファイルから読み取り"]
    AutoDetect -->|No| ShowSlots["利用可能スロットを表示<br/>→ エラー終了"]
    UseSlot --> FetchTitle["gh issue view → タイトル取得"]
    ReadSlot --> FetchTitle
    FetchTitle --> GenSlug["スラッグ生成<br/>（英数字+ハイフンのみ）"]
    GenSlug --> Branch["feature/{NUMBER}-{SLUG}"]
    Branch --> Delegate["worktree-switch.sh SLOT BRANCH"]
```

```bash
# scripts/worktree/issue.sh（スロット解決部分）
SLOT="${2:-}"
if [[ -z "$SLOT" ]]; then
    if [[ -f "$(pwd)/.worktree-slot" ]]; then                                # ①
        SLOT=$(cat "$(pwd)/.worktree-slot")
    else
        echo "エラー: スロット番号を指定してください" >&2
        # 利用可能なスロットを表示...                                          # ②
        while IFS= read -r wt_path; do
            slot_file="$wt_path/.worktree-slot"
            if [[ -f "$slot_file" ]]; then
                slot_num=$(cat "$slot_file")
                wt_branch=$(git -C "$wt_path" rev-parse --abbrev-ref HEAD ...)
                echo "  スロット $slot_num: $wt_branch" >&2
            fi
        done < <(git worktree list --porcelain | grep '^worktree ' | cut -d' ' -f2-)
        exit 1
    fi
fi
```

注目ポイント:

- ① スロット内で実行した場合、`.worktree-slot` からスロット番号を自動検出。引数の省略が可能になる
- ② メイン worktree で引数なしの場合、全スロットの状態（ブランチ名 or detached HEAD）を表示してユーザーに選択を促す

```bash
# scripts/worktree/issue.sh（ブランチ名生成部分）
SLUG=$(echo "$TITLE" | \
    sed 's/[（(][^)）]*[)）]//g' | \                         # ① 括弧内を削除
    tr '[:upper:]' '[:lower:]' | \                           # ② 小文字化
    sed 's/[^a-z0-9]/-/g' | \                                # ③ 英数字以外をハイフンに
    sed 's/-\{2,\}/-/g' | \                                  # ④ 連続ハイフンを1つに
    sed 's/^-//' | sed 's/-$//' | \                          # ⑤ 先頭・末尾のハイフン削除
    cut -c1-50 | \                                           # ⑥ 50文字で切り詰め
    sed 's/-[^-]*$//')                                       # ⑦ 不完全な末尾の単語を削除

"$SCRIPT_DIR/worktree-switch.sh" "$SLOT" "$BRANCH"          # ⑧ 委譲
```

注目ポイント:

- ①-⑦ Issue タイトルから URL フレンドリーなスラッグを生成。日本語タイトルの場合はスラッグが空になるため、フォールバックで `"issue"` を使用
- ⑧ ブランチ名生成後は `worktree-switch.sh` に完全に委譲。ブランチの存在チェック・作成は switch 側の責務

### 4. `.env` 生成（generate-env.sh）

オフセット値を受け取り、ポート計算して `.env` を生成する。このスクリプトは永続スロット方式への移行で変更なし。

```mermaid
flowchart TB
    Input["PORT_OFFSET（0-9）"] --> Calc["OFFSET = PORT_OFFSET × 100"]
    Calc --> Ports["POSTGRES: 15432 + OFFSET<br/>REDIS: 16379 + OFFSET<br/>BFF: 13000 + OFFSET<br/>..."]
    Ports --> Root[".env 生成<br/>（Docker Compose 用）"]
    Ports --> Backend["backend/.env 生成<br/>（Rust サービス用）"]
    Ports --> ApiTest["backend/.env.api-test 生成<br/>（API テスト用）"]
```

```bash
# scripts/env/generate.sh（抜粋）
PORT_OFFSET="${1:-0}"

# 基準ポート
BASE_POSTGRES_PORT=15432
BASE_REDIS_PORT=16379
BASE_BFF_PORT=13000
BASE_CORE_API_PORT=13001
BASE_VITE_PORT=15173

# オフセット計算（100 単位）
OFFSET=$((PORT_OFFSET * 100))                          # ①

POSTGRES_PORT=$((BASE_POSTGRES_PORT + OFFSET))          # ②

# ルート .env を生成
cat > "$PROJECT_ROOT/.env" << EOF
POSTGRES_PORT=$POSTGRES_PORT                             # ③
REDIS_PORT=$REDIS_PORT
BFF_PORT=$BFF_PORT
VITE_PORT=$VITE_PORT
EOF

# backend/.env を生成
cat > "$PROJECT_ROOT/backend/.env" << EOF
DATABASE_URL=postgres://ringiflow:ringiflow@localhost:$POSTGRES_PORT/ringiflow_dev  # ④
REDIS_URL=redis://localhost:$REDIS_PORT
CORE_API_PORT=$CORE_API_PORT
CORE_API_URL=http://localhost:$CORE_API_PORT
EOF
```

注目ポイント:

- ① 100 単位のオフセットで可読性と予測可能性を確保
- ② 各ベースポートにオフセットを加算
- ③ ルートの `.env` は Docker Compose が参照（`${POSTGRES_PORT}` 形式）
- ④ `backend/.env` は Rust サービスが `dotenv` で読み込み。`DATABASE_URL` にポートが反映

### 5. Docker 起動（プロジェクト名による分離）

`dev-deps` がディレクトリ名からプロジェクト名を自動取得し、Docker Compose を起動する。このタスクは永続スロット方式への移行で変更なし。

```mermaid
flowchart LR
    PWD["basename $(pwd)<br/>→ ringiflow-1"] --> Compose["docker compose<br/>-p ringiflow-1"]
    Compose --> Container["ringiflow-1-postgres-1<br/>:15532"]
    Compose --> Volume["ringiflow-1_postgres_data"]
    Compose --> Network["ringiflow-1_default"]
```

```bash
# justfile: dev-deps
dev-deps:
    #!/usr/bin/env bash
    PROJECT_NAME=$(basename "$(pwd)")                   # ① ディレクトリ名を取得
    docker compose -p "$PROJECT_NAME" -f infra/docker/docker-compose.yaml up -d --wait  # ②
```

注目ポイント:

- ① メイン worktree なら `ringiflow`、スロット 1 なら `ringiflow-1`
- ② `-p` でプロジェクト名を指定すると、コンテナ名・ボリューム名・ネットワーク名にプレフィックスが付く

### 6. クリーンアップ（cleanup.sh）

永続スロットは削除ではなく detached HEAD にリセットする。従来の worktree は Docker ごと削除する。

```mermaid
flowchart TB
    DetectStale["stale worktree を検出<br/>（マージ済みブランチ）"] --> CheckSlot{".worktree-slot<br/>マーカーあり？"}
    CheckSlot -->|Yes| Reset["永続スロット: リセット<br/>git switch --detach origin/main<br/>+ ブランチ削除"]
    CheckSlot -->|No| Delete["従来 worktree: 削除<br/>Docker down -v<br/>+ git worktree remove"]
```

```bash
# scripts/worktree/cleanup.sh（永続スロット分岐部分）
if [[ -f "$path/.worktree-slot" ]]; then                          # ①
    # 永続スロット: 削除ではなく detached HEAD にリセット
    echo "      永続スロットをリセット中..."
    git -C "$path" switch --detach origin/main 2>/dev/null || true  # ②

    if [[ "$branch" != "main" ]]; then
        git branch -D "$branch" 2>/dev/null || true                 # ③
    fi

    echo "      ✓ スロットをリセットしました（detached HEAD）"
else
    # 従来の worktree: Docker コンテナ・ボリュームごと削除
    project_name="ringiflow-${name}"
    docker compose -p "$project_name" ... down -v 2>/dev/null || true
    git worktree remove "$path" --force 2>/dev/null || true

    if [[ "$branch" != "main" ]]; then
        git branch -D "$branch" 2>/dev/null || true
    fi
fi
```

注目ポイント:

- ① `.worktree-slot` マーカーの有無で永続スロットか判定。マーカーがあればリセット、なければ従来通り削除
- ② `git -C "$path" switch --detach origin/main` で detached HEAD にリセット。次回の `worktree-switch` ですぐにブランチを割り当てられる状態にする
- ③ マージ済みのローカルブランチのみ削除。スロット自体、Docker コンテナ・ボリュームは保持される

## 設計解説

コード実装レベルの判断を記載する。機能・仕組みレベルの判断は[機能解説](./01_並行開発環境_機能解説.md#設計判断)を参照。

### 1. `env -u` による環境変数クリア

場所: `scripts/worktree/create.sh` L71-74、`scripts/worktree/switch.sh` L86-89

```bash
env -u POSTGRES_PORT -u REDIS_PORT -u DYNAMODB_PORT \
    -u API_TEST_POSTGRES_PORT -u API_TEST_REDIS_PORT -u API_TEST_DYNAMODB_PORT \
    -u BFF_PORT -u VITE_PORT \
    just setup-worktree
```

なぜこの実装か:

justfile の `dotenv-load = true` は `.env` ファイルを読み込むが、**既に環境変数が設定されている場合は上書きしない**。メインの worktree から `just worktree-create 1` を実行すると、メインの `.env` の値が環境変数として継承されるため、スロット 1 の `.env` の値が使われない。`env -u` で明示的にクリアすることで、子プロセスでは worktree 固有の `.env` が正しく読み込まれる。

代替案:

| 案 | メリット | デメリット | 判断 |
|----|---------|-----------|------|
| `env -u` で明示的にクリア（採用） | 確実、影響範囲が限定的 | 変数の列挙が必要 | 採用 |
| `env -i` で全環境変数をリセット | 全変数クリア | PATH 等も消えて just が実行できない | 見送り |
| `dotenv-override = true` に変更 | 自動で `.env` が優先 | 全タスクに影響、意図しない副作用 | 見送り |

### 2. pnpm-lock.yaml の差分チェック（fail-open 方式）

場所: `scripts/worktree/switch.sh` L92-111

```bash
PREV_HEAD=$(git -C "$WORKTREE_PATH" rev-parse HEAD 2>/dev/null || echo "")

pnpm_changed=false
if [[ -n "$PREV_HEAD" ]]; then
    if ! git diff --quiet "$PREV_HEAD"..HEAD -- pnpm-lock.yaml ...; then
        pnpm_changed=true
    fi
else
    pnpm_changed=true  # fail-open
fi
```

なぜこの実装か:

detached HEAD からの初回切り替え時、`PREV_HEAD` は取得できるが reflog が限られている場合がある。diff コマンド自体が失敗するケースもあるため、**fail-open**（失敗時は安全側 = pnpm install を実行）とする。`pnpm install` は冪等操作であり、不要な場合もロックファイルが変わっていなければ高速に完了する。

代替案:

| 案 | メリット | デメリット | 判断 |
|----|---------|-----------|------|
| fail-open（採用） | 安全、冪等 | 不要な pnpm install が走る場合がある | 採用 |
| fail-close（差分不明 → スキップ） | 高速 | 依存関係の不整合リスク | 見送り |
| 常に pnpm install | 確実 | 毎回 install で遅い | 見送り |

### 3. 未コミット変更の拒否（stash 非対応）

場所: `scripts/worktree/switch.sh` L52-59

```bash
changes=$(git -C "$WORKTREE_PATH" status --porcelain 2>/dev/null || true)
if [[ -n "$changes" ]]; then
    echo "エラー: スロット $N に未コミットの変更があります" >&2
    exit 1
fi
```

なぜこの実装か:

`git stash` を自動実行する選択肢もあるが、stash の存在を忘れて紛失するリスクがある。エラーで拒否してユーザーに明示的なアクション（commit または stash）を求める方がシンプルで安全。KISS を優先する。

代替案:

| 案 | メリット | デメリット | 判断 |
|----|---------|-----------|------|
| エラーで拒否（採用） | シンプル、安全 | 手動ステップが必要 | 採用 |
| 自動 stash | 便利 | stash の紛失リスク、復元の複雑さ | 見送り |

### 4. `basename $(pwd)` によるプロジェクト名取得

場所: `justfile` の `dev-deps`、`clean` タスク

```bash
PROJECT_NAME=$(basename "$(pwd)")
docker compose -p "$PROJECT_NAME" ...
```

なぜこの実装か:

永続スロットのディレクトリ名は `ringiflow-N` 形式で、そのまま Docker Compose のプロジェクト名として適切。固定値ではなくディレクトリ名から動的に取得することで、メイン worktree（`ringiflow`）でもスロット（`ringiflow-1`）でも同じ `justfile` で正しく動作する。

代替案:

| 案 | メリット | デメリット | 判断 |
|----|---------|-----------|------|
| `basename $(pwd)`（採用） | 動的、設定不要 | ディレクトリ名に依存 | 採用 |
| `.env` に `PROJECT_NAME` を記載 | 明示的 | 手動設定が必要 | 見送り |
| `docker compose` のデフォルト名 | 設定不要 | YAML ファイルの場所に依存 | 見送り |

### 5. スロット自動検出（worktree-issue.sh）

場所: `scripts/worktree/issue.sh` L34-63

```bash
if [[ -z "$SLOT" ]]; then
    if [[ -f "$(pwd)/.worktree-slot" ]]; then
        SLOT=$(cat "$(pwd)/.worktree-slot")
    else
        # 利用可能なスロットを表示してエラー
    fi
fi
```

なぜこの実装か:

スロット内で作業中の場合、スロット番号の指定は冗長。`.worktree-slot` マーカーから自動検出することで、`just worktree-issue 321` だけで切り替えが完了する。メイン worktree では自動検出できないため、利用可能なスロットの一覧を表示してユーザーに選択を促す。空きスロットの自動選択は実装しない（どのスロットを使うかはユーザーが意識的に選ぶべき）。

## 関連ドキュメント

- [機能解説](./01_並行開発環境_機能解説.md)
- ADR: [021_並行開発環境の構成](../../70_ADR/021_並行開発環境の構成.md)
- ナレッジベース: [git_worktree](../../80_ナレッジベース/devtools/git_worktree.md)
- 手順書: [並行開発（Worktree）](../../60_手順書/04_開発フロー/04_並行開発（Worktree）.md)
