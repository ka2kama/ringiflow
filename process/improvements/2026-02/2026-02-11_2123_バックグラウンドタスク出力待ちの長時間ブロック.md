# バックグラウンドタスク出力待ちの長時間ブロック

## 事象

`just check-all` の出力が 30000 文字で切り詰められ、exit code 1 と表示された。失敗箇所を特定するため、`just check-all 2>&1 | tail -100` をバックグラウンドで実行したが、`tail` のバッファリングにより出力ファイルが空のままだった。その状態で `TaskOutput` を `block=true`, `timeout=600000`（10分）で呼び出し、ユーザーを約30分待たせた。

## 原因分析

1. **`tail` パイプによるバッファリング**: `command 2>&1 | tail -N` をバックグラウンドで実行すると、`tail` がパイプの全入力を受け取るまで出力を保留する。結果としてバックグラウンドタスクの出力ファイルが空になり、進捗を確認できなくなった
2. **長時間ブロッキング待機**: 出力が得られない状態で `TaskOutput` を `block=true` で呼び出し続けた。進捗が見えない場合に早期に方針を切り替えるべきだった
3. **根本原因の誤認**: 最初の `just check-all` の exit code 1 は、出力切り詰めによる誤表示だった可能性が高い（再実行で exit code 0）。失敗していないものを調査しようとした

## 対策

### 対策形式の検証

| 対策案 | 形式 | 有効性 |
|--------|------|--------|
| ~~「バックグラウンドタスクの出力を定期的に確認する」~~ | 行動規範 | 低 |
| パイプなしでバックグラウンド実行し、Read/Bash で末尾を確認する | 成果物要件 | 高 |
| TaskOutput の block=true 使用時は timeout を短く設定する | 成果物要件 | 高 |

### 採用する対策

1. **バックグラウンド実行時はパイプを使わない**: コマンドの出力を直接ファイルに書き出す形でバックグラウンド実行し、`Read` ツールや `Bash` の `tail` で進捗を確認する
2. **TaskOutput の timeout は短く**: `block=true` の場合でも `timeout` は 30000ms（30秒）以下に設定し、完了していなければ `block=false` で状態確認に切り替える。10分のブロッキングは禁止
3. **出力切り詰め時の exit code を疑う**: Bash ツールの出力が切り詰められた場合、exit code が実際のコマンドの終了コードでない可能性を考慮する。パニックする前に再実行で確認する

## 次のアクション

- [x] ルールファイルに形式知化: [`.claude/rules/long-running-commands.md`](../../.claude/rules/long-running-commands.md)

## 分類

- カテゴリ: 単一パス検証（出力が空 → 「待てば出る」と判断し、別手段を検討しなかった）
- 失敗タイプ: 知識ギャップ（パイプのバッファリング挙動を考慮しなかった）
